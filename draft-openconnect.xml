<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [


 	<!ENTITY FTP SYSTEM
	"http://xml.resource.org/public/rfc/bibxml/reference.RFC.0959.xml">

	<!ENTITY HTTP SYSTEM
	"http://xml.resource.org/public/rfc/bibxml/reference.RFC.1945.xml">

	<!ENTITY MD5 SYSTEM
	"http://xml.resource.org/public/rfc/bibxml/reference.RFC.1321.xml">

	<!ENTITY TCP SYSTEM
	"http://xml.resource.org/public/rfc/bibxml/reference.RFC.0793.xml">

	<!ENTITY TEL SYSTEM
	"http://xml.resource.org/public/rfc/bibxml/reference.RFC.0854.xml">

	<!ENTITY XDR SYSTEM
	"http://xml.resource.org/public/rfc/bibxml/reference.RFC.1832.xml">

	<!ENTITY KRAW SYSTEM
	"http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml">

	<!ENTITY IP SYSTEM
	"http://xml.resource.org/public/rfc/bibxml/reference.RFC.0791.xml">

]>



<?rfc rfcedstyle="yes" ?>
<?rfc subcompact="no" ?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>

<rfc submissionType="IETF" consensus="yes" category="historic" ipr="pre5378Trust200902" number="6101">
   <front>
      <title abbrev="The OpenConnect Version 1.0">The OpenConnect VPN Protocol Version 1.0</title>

      <author initials="N." surname="Mavrogiannopoulos" fullname="Nikos Mavrogiannopoulos">
         <organization>Netscape Communications</organization>
      </author>

      <date month="June" year="2014"/>
      <area>Security</area>
<!--      <workgroup>TLS Working Group</workgroup> -->
      <keyword>SSL</keyword>
      <keyword>TLS</keyword>
      <keyword>VPN</keyword>
      <keyword>Secure sockets layer</keyword>
      <keyword>Virtual Private Network</keyword>
      <keyword>Transport layer security</keyword>


      <abstract>
<t>
   This document specifies version 1.0 of the OpenConnect VPN
   protocol, a secure VPN protocol that provides
   communications privacy over the Internet.  That protocol is believed
   to be compatible with CISCO's AnyConnect VPN protocol. The protocol allows
   the establishment of VPN tunnels in a way that is designed
   to prevent eavesdropping, tampering, or message forgery.
         </t>
      </abstract>

   </front>

<middle>


<section anchor="intro" title="Introduction">
    <t>
   The purpose of this document is to specify the OpenConnect VPN protocol
   in a detail in order to allow for multiple interoperable implementations.
   That is a protocol that is believed to be compatible with CISCO's
   AnyConnect protocol.
   </t>
   <t>
   While there are many competing VPN protocol solutions, none of
   them was ever described in a publicly available document. Even open
   source VPN solutions have their source code as the primary description
   of their protocol. That allowed no easy study of each protocol's
   properties and weaknesses, and that is one of the points addressed
   by this document.
   </t>
</section>

<section anchor="goals-document" title="Goals of This Document">
<t>
   The OpenConnect protocol version 1.0 specification is intended primarily
   for readers who will be implementing the protocol and those doing
   cryptographic analysis of it.
</t>
</section>

<section anchor="oc-protocol" title="The OpenConnect Protocol">
<t>
   SSL is a layered protocol.  At each layer, messages may include
   fields for length, description, and content.  SSL takes messages to
   be transmitted, fragments the data into manageable blocks,
   optionally compresses the data, applies a MAC, encrypts, and
   transmits the result.  Received data is decrypted, verified,
   decompressed, and reassembled, then delivered to higher level
   clients.
</t>

<section anchor="session-states" title="Session and Connection States">
<t>
   An SSL session is stateful.  It is the responsibility of the SSL
   handshake protocol to coordinate the states of the client and
   server, thereby allowing the protocol state machines of each to
   operate consistently, despite the fact that the state is not
   exactly parallel.  Logically, the state is represented twice, once
   as the current operating state and (during the handshake protocol)
   again as the pending state.  Additionally, separate read and write
   states are maintained.  When the client or server receives a change
   cipher spec message, it copies the pending read state into the
   current read state.  When the client or server sends a change
   cipher spec message, it copies the pending write state into the
   current write state.  When the handshake negotiation is complete,
   the client and server exchange change cipher spec messages (see
   <xref target="change-cipher-spec"/>), and they then communicate using the newly agreed-upon
   cipher spec.
</t>
<t>
   An SSL session may include multiple secure connections; in
   addition, parties may have multiple simultaneous sessions.
</t>
<t>
   The session state includes the following elements:

   <list style='hanging'>
     <t hangText="session identifier:">
                An arbitrary byte sequence chosen by the server
                       to identify an active or resumable session
                       state.
     </t>

      <t hangText="peer certificate:">
                X509.v3 <xref target="X509"/> certificate of the peer.  This
                       element of the state may be null.
     </t>
     <t hangText="compression method:">
                The algorithm used to compress data prior to
                       encryption.
     </t>
     <t hangText="cipher spec:">
                Specifies the bulk data encryption algorithm
                       (such as null, DES, etc.) and a MAC algorithm
                       (such as MD5 or SHA).  It also defines
                       cryptographic attributes such as the hash_size.
                       (See <xref target="the-cipherspec"/> for formal definition.)
     </t>     
     <t hangText="master secret:">
                48-byte secret shared between the client and server.
     </t>
     <t hangText="is resumable:">
                A flag indicating whether the session can be
                       used to initiate new connections.
     </t>
     </list>
</t>
<t>
   The connection state includes the following elements:
   <list style='hanging'>


     <t hangText="server and client random:">
                Byte sequences that are chosen by the server
                       and client for each connection.
     </t>
     <t hangText="server write MAC secret:">
                The secret used in MAC operations on data
                       written by the server.
     </t>
     <t hangText="client write MAC secret:">
                The secret used in MAC operations on data
                       written by the client.
     </t>
     <t hangText="server write key:">
                The bulk cipher key for data encrypted by the
                       server and decrypted by the client.
     </t>
     <t hangText="client write key:">
                The bulk cipher key for data encrypted by the
                       client and decrypted by the server.
     </t>
     <t hangText="initialization vectors:">
                When a block cipher in Cipher Block Chaining (CBC) mode is used, an
                       initialization vector (IV) is maintained for
                       each key.  This field is first initialized by
                       the SSL handshake protocol.  Thereafter, the
                       final ciphertext block from each record is
                       preserved for use with the following record.
     </t>
     <t hangText="sequence numbers:">
                Each party maintains separate sequence numbers
                       for transmitted and received messages for each
                       connection.  When a party sends or receives a
                       change cipher spec message, the appropriate
                       sequence number is set to zero.  Sequence
                       numbers are of type uint64 and may not exceed
                       2^64-1.
     </t>
     </list>
</t>
</section>

<section anchor="record-layer-1" title="Record Layer">
<t>
   The SSL record layer receives uninterpreted data from higher layers
   in non-empty blocks of arbitrary size.
</t>

<section anchor="fragmentation" title="Fragmentation">
<t>
   The record layer fragments information blocks into SSLPlaintext
   records of 2^14 bytes or less.  Client message boundaries are not
   preserved in the record layer (i.e., multiple client messages of
   the same ContentType may be coalesced into a single SSLPlaintext
   record).
</t>
<t>
<figure>
<artwork><![CDATA[
     struct {
         uint8 major, minor;
     } ProtocolVersion;

     enum {
         change_cipher_spec(20), alert(21), handshake(22),
         application_data(23), (255)
     } ContentType;

     struct {
         ContentType type;
         ProtocolVersion version;
         uint16 length;
         opaque fragment[SSLPlaintext.length];
     } SSLPlaintext;
]]></artwork>
</figure>
</t>
<t>
	<list style='hanging'>
		<t hangText="type:">
			The higher level protocol used to process the
			       enclosed fragment.
		</t>
		<t hangText="version:">
			The version of protocol being employed.  This
			       document describes SSL version 3.0 (see
			       <xref target="record-layer-2"/>).
		</t>
		<t hangText="length:">
			The length (in bytes) of the following
			       SSLPlaintext.fragment.  The length should not
			       exceed 2^14.
		</t>
		<t hangText="fragment:">
			The application data.  This data is transparent
			       and treated as an independent block to be dealt
			       with by the higher level protocol specified by
			       the type field.
		</t>
	</list>
	</t>
<!--note-->	<t>Note: Data of different SSL record layer content types may
			  be interleaved.  Application data is generally of
			  lower precedence for transmission than other content
			  types.
	</t>
</section>

<section anchor="record-compression" title="Record Compression and Decompression">
	<t>
	   All records are compressed using the compression algorithm defined
	   in the current session state.  There is always an active
	   compression algorithm; however, initially it is defined as
	   CompressionMethod.null.  The compression algorithm translates an
	   SSLPlaintext structure into an SSLCompressed structure.
	   Compression functions erase their state information whenever the
	   CipherSpec is replaced.
	</t>
<!--note--><t>Note: The CipherSpec is part of the session state
                  described in <xref target="session-states"/>.  References to fields of
                  the CipherSpec are made throughout this document
                  using presentation syntax.  A more complete
                  description of the CipherSpec is shown in <xref target="the-cipherspec"/>.
	 </t>
	<t>
	   Compression must be lossless and may not increase the content
	   length by more than 1024 bytes.  If the decompression function
	   encounters an SSLCompressed.fragment that would decompress to a
	   length in excess of 2^14 bytes, it should issue a fatal
	   decompression_failure alert (<xref target="error-alerts"/>).
	</t>

	<t>
	<figure><artwork><![CDATA[
     struct {
         ContentType type;       /* same as SSLPlaintext.type */
         ProtocolVersion version;/* same as SSLPlaintext.version */
         uint16 length;
         opaque fragment[SSLCompressed.length];
     } SSLCompressed;
	]]></artwork></figure>
	</t>
	<t>
		<list style='hanging'>
			<t hangText="length:">
				The length (in bytes) of the following
			       SSLCompressed.fragment.  The length
			       should not exceed 2^14 + 1024.
			</t>
			<t hangText="fragment:">
				The compressed form of
			       SSLPlaintext.fragment.
			</t>
		</list>
	</t>
<!--note-->	<t>Note: A CompressionMethod.null operation is an identity
                  operation; no fields are altered
                  (see <xref target="hello-messages-2"/>.)
	</t>

<!--note--><t>Implementation note: Decompression functions are responsible for
                   ensuring that messages cannot cause internal buffer
                   overflows.
	</t>
</section>    

<section anchor="record-payload" title="Record Payload Protection and the CipherSpec">
	<t>
	   All records are protected using the encryption and MAC algorithms
	   defined in the current CipherSpec.  There is always an active
	   CipherSpec; however, initially it is SSL_NULL_WITH_NULL_NULL, which
	   does not provide any security.
	</t>
	<t>
   Once the handshake is complete, the two parties have shared secrets
   that are used to encrypt records and compute keyed Message
   Authentication Codes (MACs) on their contents.  The techniques used
   to perform the encryption and MAC operations are defined by the
   CipherSpec and constrained by CipherSpec.cipher_type.  The
   encryption and MAC functions translate an SSLCompressed structure
   into an SSLCiphertext.  The decryption functions reverse the
   process.  Transmissions also include a sequence number so that
   missing, altered, or extra messages are detectable.
	</t>
	<t>
	<figure><artwork><![CDATA[
     struct {
         ContentType type;
         ProtocolVersion version;
         uint16 length;
         select (CipherSpec.cipher_type) {
             case stream: GenericStreamCipher;
             case block: GenericBlockCipher;
         } fragment;
     } SSLCiphertext;
	]]></artwork></figure>
	</t>

	<t>
		<list style='hanging'>
			<t hangText="type:">
				The type field is identical to
                       SSLCompressed.type.
			</t>
			<t hangText="version:">
				The version field is identical to
                       SSLCompressed.version.</t>
			<t hangText="length:">
				The length (in bytes) of the following
			       SSLCiphertext.fragment.  The length may
			       not exceed 2^14 + 2048.
			</t>
			<t hangText="fragment:">
				The encrypted form of
				SSLCompressed.fragment, including the
				MAC.
			</t>
                 </list>
	</t>

<section anchor="stream-cipher" title="Null or Standard Stream Cipher">
	<t>
	   Stream ciphers (including BulkCipherAlgorithm.null; see Appendix
	   A.7) convert SSLCompressed.fragment structures to and from stream
	   SSLCiphertext.fragment structures.
	</t>
	<t>
	<figure><artwork><![CDATA[
     stream-ciphered struct {
         opaque content[SSLCompressed.length];
         opaque MAC[CipherSpec.hash_size];
     } GenericStreamCipher;
	]]></artwork></figure>
	</t>
	<t>The MAC is generated as:</t>
	<t>
	<figure><artwork><![CDATA[
     hash(MAC_write_secret + pad_2 +
          hash(MAC_write_secret + pad_1 + seq_num +
               SSLCompressed.type + SSLCompressed.length +
               SSLCompressed.fragment));
	]]></artwork></figure>
	</t>
	<t>where "+" denotes concatenation.</t>

	<t>
		<list style='hanging'>
			<t hangText="pad_1:">
				The character 0x36 repeated 48 times for MD5
				or 40 times for SHA.
			</t>
			<t hangText="pad_2:">
				The character 0x5c repeated 48 times for MD5
				or 40 times for SHA.
			</t>
			<t hangText="seq_num:">
				The sequence number for this message.
			</t>
			<t hangText="hash:">
				Hashing algorithm derived from the cipher
				suite.
			</t>
		</list>
	</t>
	<t>
	   Note that the MAC is computed before encryption.  The stream cipher
	   encrypts the entire block, including the MAC.  For stream ciphers
	   that do not use a synchronization vector (such as RC4), the stream
	   cipher state from the end of one record is simply used on the
	   subsequent packet.  If the CipherSuite is SSL_NULL_WITH_NULL_NULL,
	   encryption consists of the identity operation (i.e., the data is
	   not encrypted and the MAC size is zero implying that no MAC is
	   used).  SSLCiphertext.length is SSLCompressed.length plus
	   CipherSpec.hash_size.
	</t>
</section>

<section anchor="block-cipher" title="CBC Block Cipher">
	<t>
	   For block ciphers (such as RC2 or DES), the encryption and MAC
	   functions convert SSLCompressed.fragment structures to and from
	   block SSLCiphertext.fragment structures.
	</t>
	<t>
	<figure><artwork><![CDATA[
     block-ciphered struct {
         opaque content[SSLCompressed.length];
         opaque MAC[CipherSpec.hash_size];
         uint8 padding[GenericBlockCipher.padding_length];
         uint8 padding_length;
     } GenericBlockCipher;
	]]></artwork></figure>
	</t>
	<t>The MAC is generated as described in <xref target="stream-cipher"/>.</t>
	<t>
		<list style='hanging'>
			<t hangText="padding:">
				Padding that is added to force the length of
			       the plaintext to be a multiple of the block
			       cipher's block length.
			</t>
			<t hangText="padding_length:">
				The length of the padding must be less than the
			       cipher's block length and may be zero.  The
			       padding length should be such that the total
			       size of the GenericBlockCipher structure is a
			       multiple of the cipher's block length.
			</t>
		</list>
	</t>
	<t>
	   The encrypted data length (SSLCiphertext.length) is one more than
	   the sum of SSLCompressed.length, CipherSpec.hash_size, and
	   padding_length.
	</t>
<!--note--><t>Note: With CBC, the initialization vector
                (IV) for the first record is provided by the
                handshake protocol.  The IV for subsequent records
                is the last ciphertext block from the previous
                record.
        </t>

</section>
</section>
</section>

<section anchor="change-cipher-spec" title="Change Cipher Spec Protocol">
	<t>
	   The change cipher spec protocol exists to signal transitions in
	   ciphering strategies.  The protocol consists of a single message,
	   which is encrypted and compressed under the current (not the
	   pending) CipherSpec.  The message consists of a single byte of
	   value 1.
	</t>
	<t>
	<figure><artwork><![CDATA[
     struct {
         enum { change_cipher_spec(1), (255) } type;
     } ChangeCipherSpec;
	]]></artwork></figure>
	</t>
	<t>
	   The change cipher spec message is sent by both the client and
	   server to notify the receiving party that subsequent records will
	   be protected under the just-negotiated CipherSpec and keys.
	   Reception of this message causes the receiver to copy the read
	   pending state into the read current state.  The client sends a
	   change cipher spec message following handshake key exchange and
	   certificate verify messages (if any), and the server sends one
	   after successfully processing the key exchange message it received
	   from the client.  An unexpected change cipher spec message should
	   generate an unexpected_message alert (<xref target="error-alerts"/>).  When
	   resuming a previous session, the change cipher spec message is sent
	   after the hello messages.
	</t>
</section>

<section anchor="alert-protocol" title="Alert Protocol">
	<t>
	   One of the content types supported by the SSL record layer is the
	   alert type.  Alert messages convey the severity of the message and
	   a description of the alert.  Alert messages with a level of fatal
	   result in the immediate termination of the connection.  In this
	   case, other connections corresponding to the session may continue,
	   but the session identifier must be invalidated, preventing the
	   failed session from being used to establish new connections.  Like
	   other messages, alert messages are encrypted and compressed, as
	   specified by the current connection state.
	</t>
	<t>
	<figure><artwork><![CDATA[
     enum { warning(1), fatal(2), (255) } AlertLevel;

     enum {
         close_notify(0),
         unexpected_message(10),
         bad_record_mac(20),
         decompression_failure(30),
         handshake_failure(40),
         no_certificate(41),
         bad_certificate(42),
         unsupported_certificate(43),
         certificate_revoked(44),
         certificate_expired(45),
         certificate_unknown(46),
         illegal_parameter (47)
         (255)
     } AlertDescription;

     struct {
         AlertLevel level;
         AlertDescription description;
     } Alert;
	]]></artwork></figure>
	</t>


<section anchor="closure-alerts" title="Closure Alerts">
	<t>
	   The client and the server must share knowledge that the connection
	   is ending in order to avoid a truncation attack.  Either party may
	   initiate the exchange of closing messages.
	</t>
	<t>
		<list style='hanging'>
			<t hangText="close_notify:">
				This message notifies the recipient that the
			       sender will not send any more messages on this
			       connection.  The session becomes unresumable if
			       any connection is terminated without proper
			       close_notify messages with level equal to
			       warning.
			</t>
		</list>
	</t>
	<t>
	   Either party may initiate a close by sending a close_notify alert.
	   Any data received after a closure alert is ignored.
	</t>
	<t>
	   Each party is required to send a close_notify alert before closing
	   the write side of the connection.  It is required that the other
	   party respond with a close_notify alert of its own and close down
	   the connection immediately, discarding any pending writes.  It is
	   not required for the initiator of the close to wait for the
	   responding close_notify alert before closing the read side of the
	   connection.
	</t>

<!--note--><t>NB: It is assumed that closing a connection reliably delivers
   pending data before destroying the transport.
	</t>
</section>

<section anchor="error-alerts" title="Error Alerts">
	<t>
	   Error handling in the SSL handshake protocol is very simple.  When
	   an error is detected, the detecting party sends a message to the
	   other party.  Upon transmission or receipt of a fatal alert
	   message, both parties immediately close the connection.  Servers
	   and clients are required to forget any session identifiers, keys,
	   and secrets associated with a failed connection.  The following
	   error alerts are defined:
	</t>
	<t>
		<list style='hanging'>
			<t hangText="unexpected_message:">
				An inappropriate message was received.  This
				alert is always fatal and should never be
				observed in communication between proper
				implementations.
			</t>
			<t hangText="bad_record_mac:">
				This alert is returned if a record is received
				with an incorrect MAC.  This message is always
				fatal.
			</t>
			<t hangText="decompression_failure:">
				The decompression function received improper
				input (e.g., data that would expand to excessive
				length).  This message is always fatal.
			</t>
			<t hangText="handshake_failure:">
				Reception of a handshake_failure alert message
			       indicates that the sender was unable to
			       negotiate an acceptable set of security
			       parameters given the options available.  This
			       is a fatal error.
			</t>
			<t hangText="no_certificate:">
				A no_certificate alert message may be sent in
			       response to a certification request if no
			       appropriate certificate is available.
			</t>
			<t hangText="bad_certificate:">
				A certificate was corrupt, contained signatures
				that did not verify correctly, etc.
			</t>
			<t hangText="unsupported_certificate:">
				A certificate was of an unsupported type.
			</t>
			<t hangText="certificate_revoked:">
				A certificate was revoked by its signer.
			</t>
			<t hangText="certificate_expired:">
				A certificate has expired or is not currently
				valid.
			</t>
			<t hangText="certificate_unknown:">
				Some other (unspecified) issue arose in
				processing the certificate, rendering it
				unacceptable.
			</t>
			<t hangText="illegal_parameter:">
				A field in the handshake was out of range or
				inconsistent with other fields.  This is always
				fatal.
			</t>
		</list>
	</t>
</section>
</section>

<section anchor="handshake-overview" title="Handshake Protocol Overview">
	<t>
	   The cryptographic parameters of the session state are produced by
	   the SSL handshake protocol, which operates on top of the SSL record
	   layer.  When an SSL client and server first start communicating,
	   they agree on a protocol version, select cryptographic algorithms,
	   optionally authenticate each other, and use public key encryption
	   techniques to generate shared secrets.  These processes are
	   performed in the handshake protocol, which can be summarized as
	   follows: the client sends a client hello message to which the
	   server must respond with a server hello message, or else a fatal
	   error will occur and the connection will fail.  The client hello
	   and server hello are used to establish security enhancement
	   capabilities between client and server.  The client hello and
	   server hello establish the following attributes: Protocol Version,
	   Session ID, Cipher Suite, and Compression Method.  Additionally,
	   two random values are generated and exchanged: ClientHello.random
	   and ServerHello.random.
	</t>
	<t>
	   Following the hello messages, the server will send its certificate,
	   if it is to be authenticated.  Additionally, a server key exchange
	   message may be sent, if it is required (e.g., if their server has no
	   certificate, or if its certificate is for signing only).  If the
	   server is authenticated, it may request a certificate from the
	   client, if that is appropriate to the cipher suite selected.  Now
	   the server will send the server hello done message, indicating that
	   the hello-message phase of the handshake is complete.  The server
	   will then wait for a client response.  If the server has sent a
	   certificate request message, the client must send either the
	   certificate message or a no_certificate alert.  The client key
	   exchange message is now sent, and the content of that message will
	   depend on the public key algorithm selected between the client
	   hello and the server hello.  If the client has sent a certificate
	   with signing ability, a digitally-signed certificate verify message
	   is sent to explicitly verify the certificate.
	</t>
	<t>
	   At this point, a change cipher spec message is sent by the client,
	   and the client copies the pending CipherSpec into the current
	   CipherSpec.  The client then immediately sends the finished
	   message under the new algorithms, keys, and secrets.  In response,
	   the server will send its own change cipher spec message, transfer
	   the pending to the current CipherSpec, and send its finished
	   message under the new CipherSpec.  At this point, the handshake is
	   complete and the client and server may begin to exchange
	   application layer data.  (See flow chart below.)
	</t>
	<t>
	<figure><artwork><![CDATA[
   Client                                                Server

   ClientHello                   -------->
                                                    ServerHello
                                                   Certificate*
                                             ServerKeyExchange*
                                            CertificateRequest*
                                 <--------      ServerHelloDone
   Certificate*
   ClientKeyExchange
   CertificateVerify*
   [ChangeCipherSpec]
   Finished                      -------->
                                             [ChangeCipherSpec]
                                 <--------             Finished
   Application Data              <------->     Application Data

   * Indicates optional or situation-dependent messages that are not
     always sent.
]]></artwork></figure>
	</t>

<!--note--><t>Note: To help avoid pipeline stalls, ChangeCipherSpec is
             an independent SSL protocol content type, and is not
             actually an SSL handshake message.
	</t>


	<t>
	   When the client and server decide to resume a previous session or
	   duplicate an existing session (instead of negotiating new security
	   parameters) the message flow is as follows:
	</t>
	<t>
	   The client sends a ClientHello using the session ID of the session
	   to be resumed.  The server then checks its session cache for a
	   match.  If a match is found, and the server is willing to
	   re-establish the connection under the specified session state, it
	   will send a ServerHello with the same session ID value.  At this
	   point, both client and server must send change cipher spec messages
	   and proceed directly to finished messages.  Once the
	   re-establishment is complete, the client and server may begin to
	   exchange application layer data.  (See flow chart below.) If a
	   session ID match is not found, the server generates a new session
	   ID and the SSL client and server perform a full handshake.
	</t>
	<t>
	<figure><artwork><![CDATA[
   Client                                                Server

   ClientHello                   -------->
                                                    ServerHello
                                           [change cipher spec]
                                 <--------             Finished
   change cipher spec
   Finished                      -------->
   Application Data              <------->     Application Data
]]>
	</artwork>
	</figure>
	</t>
	<t>
	   The contents and significance of each message will be presented in
	   detail in the following sections.
	</t>
</section>

<section anchor="handshake-protocol-1" title="Handshake Protocol">
	<t>
	   The SSL handshake protocol is one of the defined higher level
	   clients of the SSL record protocol.  This protocol is used to
	   negotiate the secure attributes of a session.  Handshake messages
	   are supplied to the SSL record layer, where they are encapsulated
	   within one or more SSLPlaintext structures, which are processed and
	   transmitted as specified by the current active session state.
	</t>
	<t><figure><artwork><![CDATA[
     enum {
         hello_request(0), client_hello(1), server_hello(2),
         certificate(11), server_key_exchange (12),
         certificate_request(13), server_hello_done(14),
         certificate_verify(15), client_key_exchange(16),
         finished(20), (255)
     } HandshakeType;

     struct {
         HandshakeType msg_type;    /* handshake type */
         uint24 length;             /* bytes in message */
         select (HandshakeType) {
             case hello_request: HelloRequest;
             case client_hello: ClientHello;
             case server_hello: ServerHello;
             case certificate: Certificate;
             case server_key_exchange: ServerKeyExchange;
             case certificate_request: CertificateRequest;
             case server_hello_done: ServerHelloDone;
             case certificate_verify: CertificateVerify;
             case client_key_exchange: ClientKeyExchange;
             case finished: Finished;
         } body;
     } Handshake;
]]>
	</artwork>
	</figure>
	</t>
	<t>
	   The handshake protocol messages are presented in the order they
	   must be sent; sending handshake messages in an unexpected order
	   results in a fatal error.
	</t>

<section anchor="hello-messages-1" title="Hello messages">
	<t>
	   The hello phase messages are used to exchange security enhancement
	   capabilities between the client and server.  When a new session
	   begins, the CipherSpec encryption, hash, and compression algorithms
	   are initialized to null.  The current CipherSpec is used for
	   renegotiation messages.
	</t>

<section anchor="hello-request" title="Hello Request">
	<t>
	   The hello request message may be sent by the server at any time,
	   but will be ignored by the client if the handshake protocol is
	   already underway.  It is a simple notification that the client
	   should begin the negotiation process anew by sending a client hello
	   message when convenient.
	</t>

<!--note--><t>Note: Since handshake messages are intended to have
		transmission precedence over application data, it is
		expected that the negotiation begin in no more than
		one or two times the transmission time of a maximum-length application data message.
	</t>
	<t>
	   After sending a hello request, servers should not repeat the
	   request until the subsequent handshake negotiation is complete.  A
	   client that receives a hello request while in a handshake
	   negotiation state should simply ignore the message.
	</t>
	<t>
		The structure of a hello request message is as follows:
	</t>
	<t><figure><artwork><![CDATA[
     struct { } HelloRequest;
]]></artwork></figure></t>
</section>

<section anchor="client-hello" title="Client Hello">
	<t>
	   When a client first connects to a server it is required to send the
	   client hello as its first message.  The client can also send a
	   client hello in response to a hello request or on its own
	   initiative in order to renegotiate the security parameters in an
	   existing connection.  The client hello message includes a random
	   structure, which is used later in the protocol.
	</t>
	<t><figure><artwork><![CDATA[
   struct {
       uint32 gmt_unix_time;
       opaque random_bytes[28];
   } Random;
]]>	</artwork>
	</figure>
	</t>
	<t>
		<list style="hanging">
			<t hangText="gmt_unix_time:">The current time and date in standard UNIX
			       32-bit format according to the sender's
			       internal clock.  Clocks are not required to be
			       set correctly by the basic SSL protocol; higher
			       level or application protocols may define
			       additional requirements.
			</t>
			<t hangText="random_bytes:">
				28 bytes generated by a secure random number
			       generator.
			</t>
		</list>
	</t>
	<t>
	   The client hello message includes a variable-length session
	   identifier.  If not empty, the value identifies a session between
	   the same client and server whose security parameters the client
	   wishes to reuse.  The session identifier may be from an earlier
	   connection, this connection, or another currently active
	   connection.  The second option is useful if the client only wishes
	   to update the random structures and derived values of a connection,
	   while the third option makes it possible to establish several
	   simultaneous independent secure connections without repeating the
	   full handshake protocol.  The actual contents of the SessionID are
	   defined by the server.
	</t>
	<t><figure><artwork><![CDATA[
     opaque SessionID<0..32>;
]]>	</artwork>
	</figure>
	</t>
<!--note--><t>Warning: Servers must not place confidential information in
                session identifiers or let the contents of fake
                session identifiers cause any breach of security.
        </t>
	<t>
	   The CipherSuite list, passed from the client to the server in the
	   client hello message, contains the combinations of cryptographic
	   algorithms supported by the client in order of the client's
	   preference (first choice first).  Each CipherSuite defines both a
	   key exchange algorithm and a CipherSpec.  The server will select a
	   cipher suite or, if no acceptable choices are presented, return a
	   handshake failure alert and close the connection.
	</t>
	<t><figure><artwork><![CDATA[
     uint8 CipherSuite[2];  /* Cryptographic suite selector */
]]>	</artwork>
	</figure>
	</t>
	<t>
	   The client hello includes a list of compression algorithms
	   supported by the client, ordered according to the client's
	   preference.  If the server supports none of those specified by the
	   client, the session must fail.
	</t>
	<t><figure><artwork><![CDATA[
     enum { null(0), (255) } CompressionMethod;
]]>	</artwork>
	</figure>
	</t>

<!--note--><t>Issue: Which compression methods to support is under
                investigation.
        </t>
	<t>
		The structure of the client hello is as follows.
	<figure><artwork><![CDATA[
     struct {
         ProtocolVersion client_version;
         Random random;
         SessionID session_id;
         CipherSuite cipher_suites<2..2^16-1>;
         CompressionMethod compression_methods<1..2^8-1>;
     } ClientHello;
]]>	</artwork>
	</figure>
	</t>
	
	<t>
	<list style="hanging">
		<t hangText="client_version:">
			The version of the SSL protocol by which the
                       client wishes to communicate during this
                       session.  This should be the most recent
                       (highest valued) version supported by the
                       client.  For this version of the specification,
                       the version will be 3.0 (see <xref target="ssl-2"/> for
                       details about backward compatibility).
                </t>
                <t hangText="random:">
			A client-generated random structure.</t>
		<t hangText="session_id:">
			The ID of a session the client wishes to use
                       for this connection.  This field should be
                       empty if no session_id is available or the
                       client wishes to generate new security
                       parameters.</t>
                <t hangText="cipher_suites:">
		       This is a list of the cryptographic options
                       supported by the client, sorted with the
                       client's first preference first.  If the
                       session_id field is not empty (implying a
                       session resumption request), this vector must
                       include at least the cipher_suite from that
                       session.  Values are defined in <xref target="the-ciphersuite"/>.
                </t>
                <t hangText="compression_methods:">
                       This is a list of the compression methods
                       supported by the client, sorted by client
                       preference.  If the session_id field is not
                       empty (implying a session resumption request),
                       this vector must include at least the
                       compression_method from that session.  All
                       implementations must support
                       CompressionMethod.null.
                </t>
        </list>
	</t>
	<t>
	   After sending the client hello message, the client waits for a
	   server hello message.  Any other handshake message returned by the
	   server except for a hello request is treated as a fatal error.
	</t>
	
<!--note--><t>Implementation note: Application data may not be sent before a finished
                  message has been sent.  Transmitted application data
                  is known to be insecure until a valid finished
                  message has been received.  This absolute
                  restriction is relaxed if there is a current,
                  non-null encryption on this connection.
	</t>
<!--note--><t>Forward compatibility note: In the interests of forward compatibility, it is
                  permitted for a client hello message to include
                  extra data after the compression methods.  This data
                  must be included in the handshake hashes, but must
                  otherwise be ignored.
        </t>
</section>

<section anchor="server-hello" title="Server Hello">
	<t>
		The server processes the client hello message and responds with
		either a handshake_failure alert or server hello message.
	</t>
	<t>
		<figure><artwork><![CDATA[
     struct {
         ProtocolVersion server_version;
         Random random;
         SessionID session_id;
         CipherSuite cipher_suite;
         CompressionMethod compression_method;
     } ServerHello;
]]>
		</artwork></figure>
	</t>
	<t>
	<list style="hanging">
		<t hangText="server_version:">
			This field will contain the lower of that
                       suggested by the client in the client hello and
                       the highest supported by the server.  For this
                       version of the specification, the version will
                       be 3.0 (see <xref target="ssl-2"/> for details about
                       backward compatibility).</t>
		<t hangText="random:">
		           This structure is generated by the server and
                       must be different from (and independent of)
                       ClientHello.random.</t>
		<t hangText="session_id:">
			This is the identity of the session
                       corresponding to this connection.  If the
                       ClientHello.session_id was non-empty, the
                       server will look in its session cache for a
                       match.  If a match is found and the server is
                       willing to establish the new connection using
                       the specified session state, the server will
                       respond with the same value as was supplied by
                       the client.  This indicates a resumed session
                       and dictates that the parties must proceed
                       directly to the finished messages.  Otherwise,
                       this field will contain a different value
                       identifying the new session.  The server may
                       return an empty session_id to indicate that the
                       session will not be cached and therefore cannot
                       be resumed.</t>
		<t hangText="cipher_suite:">
			The single cipher suite selected by the server
                       from the list in ClientHello.cipher_suites.
                       For resumed sessions, this field is the value
                       from the state of the session being resumed.
		</t>
		<t hangText="compression_method:">
                       The single compression algorithm selected by
                       the server from the list in
                       ClientHello.compression_methods.  For resumed
                       sessions, this field is the value from the
                       resumed session state.
		</t>
	</list>
	</t>
</section>
</section>

<section anchor="server-certificate" title="Server Certificate">
	<t>
	   If the server is to be authenticated (which is generally the case),
	   the server sends its certificate immediately following the server
	   hello message.  The certificate type must be appropriate for the
	   selected cipher suite's key exchange algorithm, and is generally an
	   X.509.v3 certificate (or a modified X.509 certificate in the case
	   of FORTEZZA(tm) <xref target="FOR"/>).  The same message type will be used for the
	   client's response to a certificate request message.
	</t>
	<t>
	<figure><artwork><![CDATA[
     opaque ASN.1Cert<1..2^24-1>;
     struct {
         ASN.1Cert certificate_list<1..2^24-1>;
     } Certificate;
]]></artwork></figure>
	</t>
	<t>
	<list style="hanging">
		<t hangText="certificate_list:">
			This is a sequence (chain) of X.509.v3
                       certificates, ordered with the sender's
                       certificate first followed by any certificate
                       authority certificates proceeding sequentially
                       upward.</t>
	</list>
	</t>

<!--note--><t>Note: PKCS #7 <xref target="PKCS7"/> is not used as the format for the
                  certificate vector because PKCS #6 <xref target="PKCS6"/> extended
                  certificates are not used.  Also, PKCS #7 defines a
                  Set rather than a Sequence, making the task of
                  parsing the list more difficult.
        </t>
</section>

<section anchor="server-key-exchange" title="Server Key Exchange Message">
	<t>
	   The server key exchange message is sent by the server if it has no
	   certificate, has a certificate only used for signing (e.g., DSS
	   <xref target="DSS"/> certificates, signing-only RSA <xref target="RSA"/> certificates), or
	   FORTEZZA KEA key exchange is used.  This message is not used if the
	   server certificate contains Diffie-Hellman <xref target="DH1"/> parameters.
	</t>
<!--note--><t>Note:
		According to current US export law, RSA moduli
                  larger than 512 bits may not be used for key
                  exchange in software exported from the US.  With
                  this message, larger RSA keys may be used as
                  signature-only certificates to sign temporary
                  shorter RSA keys for key exchange.
	</t>
	<t>
	<figure><artwork><![CDATA[
     enum { rsa, diffie_hellman, fortezza_kea }
            KeyExchangeAlgorithm;

     struct {
         opaque rsa_modulus<1..2^16-1>;
         opaque rsa_exponent<1..2^16-1>;
     } ServerRSAParams;
]]></artwork></figure>
	<list style="hanging">
		<t hangText="rsa_modulus:">The modulus of the server's temporary RSA key.</t>
		<t hangText="rsa_exponent:">The public exponent of the server's temporary RSA key.</t>
	</list>
	</t>
	<t>
	<figure><artwork><![CDATA[
     struct {
         opaque dh_p<1..2^16-1>;
         opaque dh_g<1..2^16-1>;
         opaque dh_Ys<1..2^16-1>;
     } ServerDHParams;     /* Ephemeral DH parameters */
]]></artwork></figure>
	<list style="hanging">
		<t hangText="dh_p:">The prime modulus used for the Diffie-Hellman operation.</t>
		<t hangText="dh_g:">The generator used for the Diffie-Hellman operation.</t>
		<t hangText="dh_Ys:">The server's Diffie-Hellman public value (gX mod p).</t>
	</list>
	</t>
	<t>
	<figure><artwork><![CDATA[
     struct {
         opaque r_s [128];
     } ServerFortezzaParams;
]]></artwork></figure>
	<list style="hanging">
		<t hangText="r_s:">Server random number for FORTEZZA KEA (Key Exchange Algorithm).</t>
	</list>
	</t>
	<t>
	<figure><artwork><![CDATA[
     struct {
         select (KeyExchangeAlgorithm) {
             case diffie_hellman:
                 ServerDHParams params;
                 Signature signed_params;
             case rsa:
                 ServerRSAParams params;
                 Signature signed_params;
             case fortezza_kea:
                 ServerFortezzaParams params;
         };
     } ServerKeyExchange;
]]></artwork></figure>
	<list style="hanging">
		<t hangText="params:">The server's key exchange parameters.</t>
		<t hangText="signed_params:">A hash of the corresponding params value, with the signature appropriate to that hash applied.</t>
		<t hangText="md5_hash:">MD5(ClientHello.random + ServerHello.random + ServerParams);</t>
		<t hangText="sha_hash:">SHA(ClientHello.random + ServerHello.random + ServerParams);</t>
	</list>
	</t>
	<t>
	<figure><artwork><![CDATA[
     enum { anonymous, rsa, dsa } SignatureAlgorithm;

     digitally-signed struct {
         select(SignatureAlgorithm) {
             case anonymous: struct { };
             case rsa:
                 opaque md5_hash[16];
                 opaque sha_hash[20];
             case dsa:
                 opaque sha_hash[20];
         };
     } Signature;
]]></artwork></figure>
	</t>
</section>

<section anchor="certificate-request" title="Certificate Request">
	<t>
	   A non-anonymous server can optionally request a certificate from
	   the client, if appropriate for the selected cipher suite.
	</t>
	<t>
	<figure><artwork><![CDATA[
     enum {
         rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
         rsa_ephemeral_dh(5), dss_ephemeral_dh(6), fortezza_kea(20),
         (255)
     } ClientCertificateType;

     opaque DistinguishedName<1..2^16-1>;

     struct {
         ClientCertificateType certificate_types<1..2^8-1>;
         DistinguishedName certificate_authorities<3..2^16-1>;
     } CertificateRequest;
]]>	</artwork>
	</figure>

	<list style="hanging">
		<t hangText="certificate_types:">
			This field is a list of the types of
                       certificates requested, sorted in order of the
                       server's preference.</t>
		<t hangText="certificate_authorities:">
                       A list of the distinguished names of acceptable
                       certificate authorities.
                </t>
	</list>
	</t>
	
<!--note--><t>Note:
           DistinguishedName is derived from <xref target="X509"/>.
        </t>
<!--note--><t>Note:
		It is a fatal handshake_failure alert for an
                  anonymous server to request client identification.
	</t>
</section>

<section anchor="server-hello-done" title="Server Hello Done">
	<t>
	   The server hello done message is sent by the server to indicate the
	   end of the server hello and associated messages.  After sending
	   this message, the server will wait for a client response.
	</t>

	<t>
	<figure><artwork><![CDATA[
     struct { } ServerHelloDone;
]]>
	</artwork>
	</figure>
	</t>
	<t>
	  Upon receipt of the server hello done message the client should
	   verify that the server provided a valid certificate if required and
	   check that the server hello parameters are acceptable.
	</t>
</section>

<section anchor="client-certificate" title="Client Certificate">
	<t>
	   This is the first message the client can send after receiving a
	   server hello done message.  This message is only sent if the server
	   requests a certificate.  If no suitable certificate is available,
	   the client should send a no_certificate alert instead.  This alert
	   is only a warning; however, the server may respond with a fatal
	   handshake failure alert if client authentication is required.
	   Client certificates are sent using the certificate defined in
	   <xref target="server-certificate"/>.
	</t>
<!--note--><t>Note:
            Client Diffie-Hellman certificates must match the
                  server specified Diffie-Hellman parameters.
	</t>
</section>

<section anchor="client-key-exchange" title="Client Key Exchange Message">
	<t>
	   The choice of messages depends on which public key algorithm(s) has
	   (have) been selected.  See <xref target="server-key-exchange"/> for the
	   KeyExchangeAlgorithm definition.
	</t>
	<t>
	<figure><artwork><![CDATA[
     struct {
         select (KeyExchangeAlgorithm) {
             case rsa: EncryptedPreMasterSecret;
             case diffie_hellman: ClientDiffieHellmanPublic;
             case fortezza_kea: FortezzaKeys;
         } exchange_keys;
     } ClientKeyExchange;
]]>
	</artwork>
	</figure>
	</t>
	
	<t>
		The information to select the appropriate record structure is in
		the pending session state (see <xref target="session-states"/>).
	</t>
	
<section anchor="rsa-premaster" title="RSA Encrypted Premaster Secret Message">
	<t>
	   If RSA is being used for key agreement and authentication, the
	   client generates a 48-byte premaster secret, encrypts it under the
	   public key from the server's certificate or temporary RSA key from
	   a server key exchange message, and sends the result in an encrypted
	   premaster secret message.
	</t>
	<t>
	<figure><artwork><![CDATA[
     struct {
         ProtocolVersion client_version;
         opaque random[46];
     } PreMasterSecret;
]]>
	</artwork>
	</figure>
	</t>

	<t>
	<list style="hanging">
		<t hangText="client_version:">
			The latest (newest) version supported by the
                        client.  This is used to detect version
                        roll-back attacks.</t>
		<t hangText="random:">
			46 securely-generated random bytes.</t>
	</list>
	</t>

	<t>
	<figure><artwork><![CDATA[
     struct {
         public-key-encrypted PreMasterSecret pre_master_secret;
     } EncryptedPreMasterSecret;
]]>
	</artwork>
	</figure>
	</t>

	<t>
	<list style="hanging">
		<t hangText="pre_master_secret:">
			This random value is generated by the client
                       and is used to generate the master secret, as
                       specified in <xref target="asymmetric-crypto-computations"/>.
                </t>
	</list>
	</t>
</section>

<section anchor="fortezza-key-exchange" title="FORTEZZA Key Exchange Message">
	<t>
	   Under FORTEZZA, the client derives a token encryption key (TEK)
	   using the FORTEZZA Key Exchange Algorithm (KEA).  The client's KEA
	   calculation uses the public key in the server's certificate along
	   with private parameters in the client's token.  The client sends
	   public parameters needed for the server to generate the TEK, using
	   its own private parameters.  The client generates session keys,
	   wraps them using the TEK, and sends the results to the server.  The
	   client generates IVs for the session keys and TEK and sends them
	   also.  The client generates a random 48-byte premaster secret,
	   encrypts it using the TEK, and sends the result:
	</t>
	<t>
	<figure><artwork><![CDATA[
     struct {
         opaque y_c<0..128>;
         opaque r_c[128];
         opaque y_signature[40];
         opaque wrapped_client_write_key[12];
         opaque wrapped_server_write_key[12];
         opaque client_write_iv[24];
         opaque server_write_iv[24];
         opaque master_secret_iv[24];
         block-ciphered opaque encrypted_pre_master_secret[48];
     } FortezzaKeys;
]]>
	</artwork>
	</figure>
	</t>
	<t>
	<list style="hanging">
		<t hangText="y_signature:">
			y_signature is the signature of the KEA public
                       key, signed with the client's DSS private key.</t>
		<t hangText="y_c:">
		       The client's Yc value (public key) for the KEA
                       calculation.  If the client has sent a
                       certificate, and its KEA public key is
                       suitable, this value must be empty since the
                       certificate already contains this value.  If
                       the client sent a certificate without a
                       suitable public key, y_c is used and
                       y_signature is the KEA public key signed with
                       the client's DSS private key.  For this value
                       to be used, it must be between 64 and 128
                       bytes.</t>
		<t hangText="r_c:">
			The client's Rc value for the KEA calculation.
			</t>
		<t hangText="wrapped_client_write_key:">
                       This is the client's write key, wrapped by the
                       TEK.</t>
		<t hangText="wrapped_server_write_key:">
                       This is the server's write key, wrapped by the
                       TEK.</t>
		<t hangText="client_write_iv:">The IV for the client write key.</t>
		<t hangText="server_write_iv:">The IV for the server write key.</t>
		<t hangText="master_secret_iv:">This is the IV for the TEK used to encrypt the
                       premaster secret.</t>
		<t hangText="pre_master_secret:">A random value, generated by the client and
                       used to generate the master secret, as
                       specified in <xref target="asymmetric-crypto-computations"/>.  In the above
                       structure, it is encrypted using the TEK.</t>
	</list>
	</t>
</section>

<section anchor="client-diffie-hellman" title="Client Diffie-Hellman Public Value">
	<t>
	   This structure conveys the client's Diffie-Hellman public value
	   (Yc) if it was not already included in the client's certificate.
	   The encoding used for Yc is determined by the enumerated
	   PublicValueEncoding.
	</t>
	<t>
	<figure><artwork><![CDATA[
     enum { implicit, explicit } PublicValueEncoding;
]]>
	</artwork>
	</figure>
	</t>
	<t>
	<list style="hanging">
		<t hangText="implicit:">
			If the client certificate already contains the
                       public value, then it is implicit and Yc does
                       not need to be sent again.</t>
                <t hangText="explicit:">Yc needs to be sent.</t>
	</list>
	</t>

	<t>
	<figure><artwork><![CDATA[
     struct {
         select (PublicValueEncoding) {
             case implicit: struct { };
             case explicit: opaque dh_Yc<1..2^16-1>;
         } dh_public;
     } ClientDiffieHellmanPublic;
]]>
	</artwork>
	</figure>
	</t>

	<t>
	<list style="hanging">
		<t hangText="dh_Yc:">The client's Diffie-Hellman public value (Yc).</t>
	</list>
	</t>
</section>
</section>

<section anchor="certificate-verify" title="Certificate Verify">
	<t>
	   This message is used to provide explicit verification of a client
	   certificate.  This message is only sent following any client
	   certificate that has signing capability (i.e., all certificates
	   except those containing fixed Diffie-Hellman parameters).
	</t>
	<t>
	<figure><artwork><![CDATA[
       struct {
            Signature signature;
       } CertificateVerify;

     CertificateVerify.signature.md5_hash
                MD5(master_secret + pad_2 +
                    MD5(handshake_messages + master_secret + pad_1));
     Certificate.signature.sha_hash
                SHA(master_secret + pad_2 +
                    SHA(handshake_messages + master_secret + pad_1));
]]>
	</artwork>
	</figure>
	</t>

	<t>
	<list style="hanging">
		<t hangText="pad_1:">This is identical to the pad_1 defined in
			Section 5.2.3.1.</t>
		<t hangText="pad_2:">This is identical to the pad_2 defined in
			Section 5.2.3.1.</t>
	</list>
	</t>
	<t>
		Here, handshake_messages refers to all handshake messages starting
		at client hello up to but not including this message.
	</t>
</section>

<section anchor="finished" title="Finished">
	<t>
	   A finished message is always sent immediately after a change cipher
	   spec message to verify that the key exchange and authentication
	   processes were successful.  The finished message is the first
	   protected with the just-negotiated algorithms, keys, and secrets.
	   No acknowledgment of the finished message is required; parties may
	   begin sending encrypted data immediately after sending the finished
	   message.  Recipients of finished messages must verify that the
	   contents are correct.
	</t>
	<t>
	<figure><artwork><![CDATA[
     enum { client(0x434C4E54), server(0x53525652) } Sender;

     struct {
         opaque md5_hash[16];
         opaque sha_hash[20];
     } Finished;
]]>
	</artwork>
	</figure>
	</t>

	<t>
	<list style="hanging">
		<t hangText="md5_hash:">
			<![CDATA[MD5(master_secret + pad2 +
                        MD5(handshake_messages + Sender +
                            master_secret + pad1));]]></t>
		<t hangText="sha_hash:"><![CDATA[SHA(master_secret + pad2 +
                         SHA(handshake_messages + Sender +
                             master_secret + pad1));]]></t>
		<t hangText="handshake_messages:">All of the data from all handshake messages
                           up to but not including this message.  This
                           is only data visible at the handshake layer
                           and does not include record layer headers.</t>
	</list>
	</t>
	<t>
	   It is a fatal error if a finished message is not preceeded by a
	   change cipher spec message at the appropriate point in the
	   handshake.
	</t>
	<t>
	   The hash contained in finished messages sent by the server
	   incorporate Sender.server; those sent by the client incorporate
	   Sender.client.  The value handshake_messages includes all handshake
	   messages starting at client hello up to but not including this
	   finished message.  This may be different from handshake_messages in
	   <xref target="certificate-verify"/> because it would include the certificate verify
	   message (if sent).
	</t>

<!--note--><t>Note:
             Change cipher spec messages are not handshake
                  messages and are not included in the hash
                  computations.
	</t>
</section>
</section>

<section anchor="application-data" title="Application Data Protocol">
	<t>
	   Application data messages are carried by the record layer and are
	   fragmented, compressed, and encrypted based on the current
	   connection state.  The messages are treated as transparent data to
	   the record layer.
	</t>
</section>
</section>

<section anchor="crypto-computations" title="Cryptographic Computations">
	<t>
	   The key exchange, authentication, encryption, and MAC algorithms
	   are determined by the cipher_suite selected by the server and
	   revealed in the server hello message.
	</t>

<section anchor="asymmetric-crypto-computations" title="Asymmetric Cryptographic Computations">
	<t>
	   The asymmetric algorithms are used in the handshake protocol to
	   authenticate parties and to generate shared keys and secrets.
	</t>
	<t>
	   For Diffie-Hellman, RSA, and FORTEZZA, the same algorithm is used
	   to convert the pre_master_secret into the master_secret.  The
	   pre_master_secret should be deleted from memory once the
	   master_secret has been computed.
	</t>
	<t>
	<figure><artwork><![CDATA[
     master_secret =
       MD5(pre_master_secret + SHA('A' + pre_master_secret +
           ClientHello.random + ServerHello.random)) +
       MD5(pre_master_secret + SHA('BB' + pre_master_secret +
           ClientHello.random + ServerHello.random)) +
       MD5(pre_master_secret + SHA('CCC' + pre_master_secret +
           ClientHello.random + ServerHello.random));
]]>
	</artwork>
	</figure>
	</t>

<section anchor="rsa" title="RSA">
	<t>
	   When RSA is used for server authentication and key exchange, a
	   48-byte pre_master_secret is generated by the client, encrypted
	   under the server's public key, and sent to the server.  The server
	   uses its private key to decrypt the pre_master_secret.  Both
	   parties then convert the pre_master_secret into the master_secret,
	   as specified above.
	</t>
	<t>
	   RSA digital signatures are performed using PKCS #1 <xref target="PKCS1"/> block
	   type&nbsp;1.  RSA public key encryption is performed using PKCS #1 block
	   type&nbsp;2.
	</t>
</section>

<section anchor="diffie-hellman" title="Diffie-Hellman">
	<t>
	   A conventional Diffie-Hellman computation is performed.  The
	   negotiated key (Z) is used as the pre_master_secret, and is
	   converted into the master_secret, as specified above.
	</t>

<!--note--><t>Note:
		Diffie-Hellman parameters are specified by the
                  server, and may be either ephemeral or contained
                  within the server's certificate.
	</t>
</section>

<section anchor="fortezza" title="FORTEZZA">
	<t>
	   A random 48-byte pre_master_secret is sent encrypted under the TEK
	   and its IV.  The server decrypts the pre_master_secret and converts
	   it into a master_secret, as specified above.  Bulk cipher keys and
	   IVs for encryption are generated by the client's token and
	   exchanged in the key exchange message; the master_secret is only
	   used for MAC computations.
	</t>
</section>
</section>

<section anchor="smccc" title="Symmetric Cryptographic Calculations and the CipherSpec">
	<t>
	   The technique used to encrypt and verify the integrity of SSL
	   records is specified by the currently active CipherSpec.  A typical
	   example would be to encrypt data using DES and generate
	   authentication codes using MD5.  The encryption and MAC algorithms
	   are set to SSL_NULL_WITH_NULL_NULL at the beginning of the SSL
	   handshake protocol, indicating that no message authentication or
	   encryption is performed.  The handshake protocol is used to
	   negotiate a more secure CipherSpec and to generate cryptographic
	   keys.
	</t>

<section anchor="master-secret" title="The Master Secret">
	<t>
	   Before secure encryption or integrity verification can be performed
	   on records, the client and server need to generate shared secret
	   information known only to themselves.  This value is a 48-byte
	   quantity called the master secret.  The master secret is used to
	   generate keys and secrets for encryption and MAC computations.
	   Some algorithms, such as FORTEZZA, may have their own procedure for
	   generating encryption keys (the master secret is used only for MAC
	   computations in FORTEZZA).
	</t>
</section>

<section anchor="converting-master-secret" title="Converting the Master Secret into Keys and MAC Secrets">
	<t>The master secret is hashed into a sequence of secure bytes, which
   are assigned to the MAC secrets, keys, and non-export IVs required
   by the current CipherSpec (see <xref target="the-cipherspec"/>).  CipherSpecs require
   a client write MAC secret, a server write MAC secret, a client
   write key, a server write key, a client write IV, and a server
   write IV, which are generated from the master secret in that order.
   Unused values, such as FORTEZZA keys communicated in the
   KeyExchange message, are empty.  The following inputs are available
   to the key definition process:
	</t>
	<t>
	<figure><artwork><![CDATA[
       opaque MasterSecret[48]
       ClientHello.random
       ServerHello.random
]]>
	</artwork>
	</figure>
	</t>
	<t>
	   When generating keys and MAC secrets, the master secret is used as
	   an entropy source, and the random values provide unencrypted salt
	   material and IVs for exportable ciphers.
	</t>
	<t>
		To generate the key material, compute
	<figure><artwork><![CDATA[
     key_block =
       MD5(master_secret + SHA(`A' + master_secret +
                               ServerHello.random +
                               ClientHello.random)) +
       MD5(master_secret + SHA(`BB' + master_secret +
                               ServerHello.random +
                               ClientHello.random)) +
       MD5(master_secret + SHA(`CCC' + master_secret +
                               ServerHello.random +
                               ClientHello.random)) + [...];
]]>
	</artwork>
	</figure>
   until enough output has been generated.  Then, the key_block is
   partitioned as follows.
	</t>
	<t>
	<figure><artwork><![CDATA[
     client_write_MAC_secret[CipherSpec.hash_size]
     server_write_MAC_secret[CipherSpec.hash_size]
     client_write_key[CipherSpec.key_material]
     server_write_key[CipherSpec.key_material]
     client_write_IV[CipherSpec.IV_size] /* non-export ciphers */
     server_write_IV[CipherSpec.IV_size] /* non-export ciphers */
]]>
	</artwork>
	</figure>
	</t>
	<t>
   Any extra key_block material is discarded.
	</t>
	<t>
   Exportable encryption algorithms (for which
   CipherSpec.is_exportable is true) require additional processing as
   follows to derive their final write keys:
	</t>
	<t>
	<figure><artwork><![CDATA[
     final_client_write_key = MD5(client_write_key +
                                  ClientHello.random +
                                  ServerHello.random);
     final_server_write_key = MD5(server_write_key +
                                  ServerHello.random +
                                  ClientHello.random);
]]>
	</artwork>
	</figure>
	</t>
	<t>
   Exportable encryption algorithms derive their IVs from the random
   messages:
	</t>
	<t>
	<figure><artwork><![CDATA[
     client_write_IV = MD5(ClientHello.random + ServerHello.random);
     server_write_IV = MD5(ServerHello.random + ClientHello.random);
]]>
	</artwork>
	</figure>
	</t>
	<t>
   MD5 outputs are trimmed to the appropriate size by discarding the
   least-significant bytes.
	</t>

<section anchor="export-key-generation" title="Export Key Generation Example">
	<t>
	   SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5 requires five random bytes for
	   each of the two encryption keys and 16 bytes for each of the MAC
	   keys, for a total of 42 bytes of key material.  MD5 produces 16
	   bytes of output per call, so three calls to MD5 are required.  The
	   MD5 outputs are concatenated into a 48-byte key_block with the
	   first MD5 call providing bytes zero through 15, the second
	   providing bytes 16 through 31, etc.  The key_block is partitioned,
	   and the write keys are salted because this is an exportable
	   encryption algorithm.
	</t>
	<t>
	<figure><artwork><![CDATA[
     client_write_MAC_secret = key_block[0..15]
     server_write_MAC_secret = key_block[16..31]
     client_write_key      = key_block[32..36]
     server_write_key      = key_block[37..41]
     final_client_write_key = MD5(client_write_key +
                                  ClientHello.random +
                                  ServerHello.random)[0..15];
     final_server_write_key = MD5(server_write_key +
                                  ServerHello.random +
                                  ClientHello.random)[0..15];
     client_write_IV = MD5(ClientHello.random +
                           ServerHello.random)[0..7];
     server_write_IV = MD5(ServerHello.random +
                           ClientHello.random)[0..7];
]]>
	</artwork>
	</figure>
	</t>
</section>
</section>
</section>

</section>

<section anchor="security-considerations" title="Security Considerations">
<t>
See <xref target="security-analysis"/>.
</t>
</section>



</middle>

<back>

<references title="Informative References">


	<reference anchor='DH1'>
	<front>
	    <title>New Directions in Cryptography</title>
	    <author initials='W.' surname='Diffie'
		    fullname='W. Diffie'>
	    </author>
	    <author initials='M. E.' surname='Hellman'
		    fullname='M. E. Hellman'>
	    </author>

	    <date month='June' year='1977' />
	</front>
	<seriesInfo name="IEEE Transactions on Information Theory" value="V. IT-22, n. 6, pp. 74-84"/>
	</reference>

	<reference anchor='SSL-2'>
	<front>
	    <title>The SSL Protocol</title>
	    <author initials='K. E. B.' surname='Hickman'
		    fullname='Kipp E. B. Hickman'>
	    </author>

	    <date month='February' year='1995' />
	</front>
	</reference>


	<reference anchor='3DES'>
	<front>
	    <title>Hellman Presents No Shortcut Solutions To DES</title>
	    <author initials='W.' surname='Tuchman'
		    fullname='W. Tuchman'>
	    </author>

	    <date month='July' year='1979' />
	</front>
	<seriesInfo name="IEEE Spectrum, v. 16, n. 7," value="pp 40-41"/>
	</reference>

	<reference anchor='DES'>
	<front>
	    <title>American National Standard for
	Information Systems-Data Link Encryption</title>
	    <author><organization>ANSI X3.106</organization>
	    </author>

	    <date year='1983' />
	</front>
	<seriesInfo name="American National Standards" value="Institute"/>
	</reference>

	<reference anchor='DSS'>
	<front>
	    <title>Digital Signature Standard</title>
	    <author><organization>NIST FIPS PUB 186</organization>
	    </author>

	    <date day="18" month='May' year='1994' />
	</front>
	<seriesInfo name="National Institute of Standards and Technology" value="U.S. Department of Commerce"/>
	</reference>

	<reference anchor='FOR'>
	<front>
	    <title>FORTEZZA: Application Implementers Guide</title>
	    <author><organization>NSA X22</organization>
	    </author>

	    <date day="6" month='April' year='1995' />
	</front>
	<seriesInfo name="Document" value="# PD4002103-1.01"/>
	</reference>


	<!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.959.xml"?-->
	&FTP;

	<!-- HERE I updated the reference to the RFC version of HTTP protocol.
	     The original was:
		[HTTP] T. Berners-Lee, R. Fielding, H. Frystyk, Hypertext
		Transfer Protocol -- HTTP/1.0, October, 1995.
	-->
	<!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.0791.xml"?-->
	&IP;

	<!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.1945.xml"?-->
	&HTTP;


	<!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.1321.xml"?-->
	&MD5;

	<!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.793.xml"?-->
	&TCP;

	<!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.854.xml"?-->
	&TEL;

	<!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.1832.xml"?-->
	&XDR;
	
	<!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml"?-->
	&KRAW;

	<reference anchor='IDEA'>
	<front>
	    <title>On the Design and Security of Block Ciphers</title>
	    <author initials='X.' surname='Lai'
		    fullname='X. Lai'>
	    </author>

	    <date year='1992' />
	</front>
	<seriesInfo name="ETH Series in Information Processing, v. 1,
   Konstanz: Hartung-Gorre" value="Verlag"/>
	</reference>

	<reference anchor='PKCS1'>
	<front>
	    <title>PKCS #1: RSA Encryption Standard version 1.5</title>
	    <author><organization>RSA Laboratories</organization>
	    </author>

	    <date month="November" year='1993' />
	</front>
	</reference>

	<reference anchor='PKCS6'>
	<front>
	    <title>PKCS #6: RSA Extended Certificate
   Syntax Standard version 1.5</title>
	    <author><organization>RSA Laboratories</organization>
	    </author>

	    <date month="November" year='1993' />
	</front>
	</reference>

	<reference anchor='PKCS7'>
	<front>
	    <title>PKCS #7: RSA Cryptographic
   Message Syntax Standard version 1.5</title>
	    <author><organization>RSA Laboratories</organization>
	    </author>

	    <date month="November" year='1993' />
	</front>
	</reference>

	<reference anchor='RSA'>
	<front>
	    <title>A Method for Obtaining Digital Signatures and Public-Key Cryptosystems</title>
	    <author initials='R.' surname='Rivest'
		    fullname='R. Rivest'>
	    </author>
	    <author initials='A.' surname='Shamir'
		    fullname='A. Shamir'>
	    </author>
	    <author initials='L. M.' surname='Adleman'
		    fullname='L. M. Adleman'>
	    </author>

	    <date month='February' year='1978' />
	</front>
	<seriesInfo name="Communications of the ACM" value="v. 21, n. 2 pp. 120-126."/>
	</reference>


	<reference anchor='SCH'>
	<front>
	    <title>Applied Cryptography: Protocols,
   Algorithms, and Source Code in C</title>
	    <author initials='B.' surname='Schneier'
		    fullname='B. Schneier'>
	    </author>

	    <date year='1994' />
	</front>
	<seriesInfo name="John Wiley" value="& Sons"/>
	</reference>

	<reference anchor='SHA'>
	<front>
	    <title>Secure Hash Standard</title>
	    <author>
	    <organization>NIST FIPS PUB 180-1</organization>
	    </author>

	    <date day="31" month="May" year='1994' />
	</front>
	<annotation>
	National
   Institute of Standards and Technology, U.S. Department of
   Commerce, DRAFT</annotation>
	</reference>

	<reference anchor='X509'>
	<front>
	    <title>The Directory - Authentication Framework</title>
	    <author>
	    <organization>CCITT</organization>
	    </author>

	    <date year='1988' />
	</front>
	<seriesInfo name="Recommendation X.509" value=""/>
	</reference>

	<reference anchor='RSADSI'>
	<front>
	    <title>Unpublished works</title>
	    <author>
	    <organization>RSA Data Security, Inc.</organization>
	    <address>
	    <phone>415-595-8782</phone>
	    </address>
	    </author>
	</front>
	</reference>
	

</references>


<section anchor="protocol-constant-values" title="Protocol Constant Values">
	<t>This section describes protocol types and constants.</t>


<section anchor="record-layer-2" title="Record Layer">
<!-- This was corrected to be in the correct level -->
	<t>
	<figure><artwork><![CDATA[
     struct {
         uint8 major, minor;
     } ProtocolVersion;

     ProtocolVersion version = { 3,0 };

     enum {
         change_cipher_spec(20), alert(21), handshake(22),
         application_data(23), (255)
     } ContentType;

     struct {
         ContentType type;
         ProtocolVersion version;
         uint16 length;
         opaque fragment[SSLPlaintext.length];
     } SSLPlaintext;

     struct {
         ContentType type;
         ProtocolVersion version;
         uint16 length;
         opaque fragment[SSLCompressed.length];
     } SSLCompressed;

     struct {
         ContentType type;
         ProtocolVersion version;
         uint16 length;
         select (CipherSpec.cipher_type) {
             case stream: GenericStreamCipher;
             case block:  GenericBlockCipher;
         } fragment;
     } SSLCiphertext;

     stream-ciphered struct {
         opaque content[SSLCompressed.length];
         opaque MAC[CipherSpec.hash_size];
     } GenericStreamCipher;

     block-ciphered struct {
         opaque content[SSLCompressed.length];
         opaque MAC[CipherSpec.hash_size];
         uint8 padding[GenericBlockCipher.padding_length];
         uint8 padding_length;
     } GenericBlockCipher;
]]>
	</artwork>
	</figure>
	</t>
</section>

<section anchor="change-cipher-specs-message" title="Change Cipher Specs Message">
	<t>
	<figure><artwork><![CDATA[
     struct {
         enum { change_cipher_spec(1), (255) } type;
     } ChangeCipherSpec;
]]>
	</artwork>
	</figure>
	</t>
</section>

<section anchor="alert-messages" title="Alert Messages">
	<t>
	<figure><artwork><![CDATA[
     enum { warning(1), fatal(2), (255) } AlertLevel;

     enum {
         close_notify(0),
         unexpected_message(10),
         bad_record_mac(20),
         decompression_failure(30),
         handshake_failure(40),
         no_certificate(41),
         bad_certificate(42),
         unsupported_certificate(43),
         certificate_revoked(44),
         certificate_expired(45),
         certificate_unknown(46),
         illegal_parameter (47),
         (255)
     } AlertDescription;

     struct {
         AlertLevel level;
         AlertDescription description;
     } Alert;
]]>
	</artwork>
	</figure>
	</t>
</section>


<section anchor="handshake-protocol-2" title="Handshake Protocol">
	<t>
	<figure><artwork><![CDATA[
   enum {
       hello_request(0), client_hello(1), server_hello(2),
       certificate(11), server_key_exchange (12),
       certificate_request(13), server_done(14),
       certificate_verify(15), client_key_exchange(16),
       finished(20), (255)
   } HandshakeType;

     struct {
         HandshakeType msg_type;
         uint24 length;
         select (HandshakeType) {
             case hello_request: HelloRequest;
             case client_hello: ClientHello;
             case server_hello: ServerHello;
             case certificate: Certificate;
             case server_key_exchange: ServerKeyExchange;
             case certificate_request: CertificateRequest;
             case server_done: ServerHelloDone;
             case certificate_verify: CertificateVerify;
             case client_key_exchange: ClientKeyExchange;
             case finished: Finished;
         } body;
     } Handshake;
]]>
	</artwork>
	</figure>
	</t>

<section anchor="hello-messages-2" title="Hello Messages">
	<t>
	<figure><artwork><![CDATA[
     struct { } HelloRequest;

     struct {
         uint32 gmt_unix_time;
         opaque random_bytes[28];
     } Random;

     opaque SessionID<0..32>;

     uint8 CipherSuite[2];

     enum { null(0), (255) } CompressionMethod;

     struct {
         ProtocolVersion client_version;
         Random random;
         SessionID session_id;
         CipherSuite cipher_suites<0..2^16-1>;
         CompressionMethod compression_methods<0..2^8-1>;
     } ClientHello;

     struct {
         ProtocolVersion server_version;
         Random random;
         SessionID session_id;
         CipherSuite cipher_suite;
         CompressionMethod compression_method;
     } ServerHello;
]]>
	</artwork>
	</figure>
	</t>
</section>

<section anchor="server-authentication" title="Server Authentication and Key Exchange Messages">
	<t>
	<figure><artwork><![CDATA[
     opaque ASN.1Cert<2^24-1>;

     struct {
         ASN.1Cert certificate_list<1..2^24-1>;
     } Certificate;

     enum { rsa, diffie_hellman, fortezza_kea } KeyExchangeAlgorithm;

     struct {
         opaque RSA_modulus<1..2^16-1>;
         opaque RSA_exponent<1..2^16-1>;
     } ServerRSAParams;

     struct {
         opaque DH_p<1..2^16-1>;
         opaque DH_g<1..2^16-1>;
         opaque DH_Ys<1..2^16-1>;
     } ServerDHParams;

     struct {
         opaque r_s [128]
     } ServerFortezzaParams

     struct {
         select (KeyExchangeAlgorithm) {
             case diffie_hellman:
                 ServerDHParams params;
                 Signature signed_params;
             case rsa:
                 ServerRSAParams params;
                 Signature signed_params;
             case fortezza_kea:
                 ServerFortezzaParams params;
         };
     } ServerKeyExchange;

     enum { anonymous, rsa, dsa } SignatureAlgorithm;

     digitally-signed struct {
         select(SignatureAlgorithm) {
             case anonymous: struct { };
             case rsa:
                 opaque md5_hash[16];
                 opaque sha_hash[20];
             case dsa:
                 opaque sha_hash[20];
         };
     } Signature;


     enum {
         RSA_sign(1), DSS_sign(2), RSA_fixed_DH(3),
         DSS_fixed_DH(4), RSA_ephemeral_DH(5), DSS_ephemeral_DH(6),
         FORTEZZA_MISSI(20), (255)
     } CertificateType;

     opaque DistinguishedName<1..2^16-1>;

     struct {
         CertificateType certificate_types<1..2^8-1>;
         DistinguishedName certificate_authorities<3..2^16-1>;
     } CertificateRequest;

     struct { } ServerHelloDone;
]]>
	</artwork>
	</figure>
	</t>
</section>
</section>

<section anchor="client-authentication" title="Client Authentication and Key Exchange Messages">
	<t>
	<figure><artwork><![CDATA[
     struct {
         select (KeyExchangeAlgorithm) {
             case rsa: EncryptedPreMasterSecret;
             case diffie_hellman: DiffieHellmanClientPublicValue;
             case fortezza_kea: FortezzaKeys;
         } exchange_keys;
     } ClientKeyExchange;

     struct {
         ProtocolVersion client_version;
         opaque random[46];
     } PreMasterSecret;

     struct {
         public-key-encrypted PreMasterSecret pre_master_secret;
     } EncryptedPreMasterSecret;

     struct {
         opaque y_c<0..128>;
         opaque r_c[128];
         opaque y_signature[40];
         opaque wrapped_client_write_key[12];
         opaque wrapped_server_write_key[12];
         opaque client_write_iv[24];
         opaque server_write_iv[24];
         opaque master_secret_iv[24];
         opaque encrypted_preMasterSecret[48];
     } FortezzaKeys;

     enum { implicit, explicit } PublicValueEncoding;

     struct {
         select (PublicValueEncoding) {
             case implicit: struct {};
             case explicit: opaque DH_Yc<1..2^16-1>;
         } dh_public;
     } ClientDiffieHellmanPublic;

     struct {
         Signature signature;
     } CertificateVerify;
]]>
	</artwork>
	</figure>
	</t>

<section anchor="handshake-finalization" title="Handshake Finalization Message">
	<t>
	<figure><artwork><![CDATA[
     struct {
         opaque md5_hash[16];
         opaque sha_hash[20];
     } Finished;
]]>
	</artwork>
	</figure>
	</t>
</section>
</section>

<section anchor="the-ciphersuite" title="The CipherSuite">
	<t>
	   The following values define the CipherSuite codes used in the
	   client hello and server hello messages.
	</t>
	<t>
		A CipherSuite defines a cipher specifications supported in SSL
		version 3.0.
	</t>
	<t>
	<figure><artwork><![CDATA[
  CipherSuite SSL_NULL_WITH_NULL_NULL                = { 0x00,0x00 };
]]>
	</artwork>
	</figure>
	</t>
	<t>
	   The following CipherSuite definitions require that the server
	   provide an RSA certificate that can be used for key exchange.  The
	   server may request either an RSA or a DSS signature-capable
	   certificate in the certificate request message.
	</t>
	<t>
	<figure><artwork><![CDATA[
  CipherSuite SSL_RSA_WITH_NULL_MD5                  = { 0x00,0x01 };
  CipherSuite SSL_RSA_WITH_NULL_SHA                  = { 0x00,0x02 };
  CipherSuite SSL_RSA_EXPORT_WITH_RC4_40_MD5         = { 0x00,0x03 };
  CipherSuite SSL_RSA_WITH_RC4_128_MD5               = { 0x00,0x04 };
  CipherSuite SSL_RSA_WITH_RC4_128_SHA               = { 0x00,0x05 };
  CipherSuite SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5     = { 0x00,0x06 };
  CipherSuite SSL_RSA_WITH_IDEA_CBC_SHA              = { 0x00,0x07 };
  CipherSuite SSL_RSA_EXPORT_WITH_DES40_CBC_SHA      = { 0x00,0x08 };
  CipherSuite SSL_RSA_WITH_DES_CBC_SHA               = { 0x00,0x09 };
  CipherSuite SSL_RSA_WITH_3DES_EDE_CBC_SHA          = { 0x00,0x0A };
]]>
	</artwork>
	</figure>
	</t>
	<t>
	   The following CipherSuite definitions are used for
	   server-authenticated (and optionally client-authenticated)
	   Diffie-Hellman.  DH denotes cipher suites in which the server's
	   certificate contains the Diffie-Hellman parameters signed by the
	   certificate authority (CA).  DHE denotes ephemeral Diffie-Hellman,
	   where the Diffie-Hellman parameters are signed by a DSS or RSA
	   certificate, which has been signed by the CA.  The signing
	   algorithm used is specified after the DH or DHE parameter.  In all
	   cases, the client must have the same type of certificate, and must
	   use the Diffie-Hellman parameters chosen by the server.
	</t>
	<t>
	<figure><artwork><![CDATA[
  CipherSuite SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0B };
  CipherSuite SSL_DH_DSS_WITH_DES_CBC_SHA            = { 0x00,0x0C };
  CipherSuite SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x0D };
  CipherSuite SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0E };
  CipherSuite SSL_DH_RSA_WITH_DES_CBC_SHA            = { 0x00,0x0F };
  CipherSuite SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x10 };
  CipherSuite SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x11 };
  CipherSuite SSL_DHE_DSS_WITH_DES_CBC_SHA           = { 0x00,0x12 };
  CipherSuite SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x13 };
  CipherSuite SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x14 };
  CipherSuite SSL_DHE_RSA_WITH_DES_CBC_SHA           = { 0x00,0x15 };
  CipherSuite SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x16 };
]]>
	</artwork>
	</figure>
	</t>
	<t>
	   The following cipher suites are used for completely anonymous
	   Diffie-Hellman communications in which neither party is
	   authenticated.  Note that this mode is vulnerable to
	   man-in-the-middle attacks and is therefore strongly discouraged.
	</t>
	<t>
	<figure><artwork><![CDATA[
  CipherSuite SSL_DH_anon_EXPORT_WITH_RC4_40_MD5     = { 0x00,0x17 };
  CipherSuite SSL_DH_anon_WITH_RC4_128_MD5           = { 0x00,0x18 };
  CipherSuite SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x19 };
  CipherSuite SSL_DH_anon_WITH_DES_CBC_SHA           = { 0x00,0x1A };
  CipherSuite SSL_DH_anon_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x1B };
]]>
	</artwork>
	</figure>
	</t>
	<t>
		The final cipher suites are for the FORTEZZA token.
	</t>
	<t>
	<figure><artwork><![CDATA[
  CipherSuite SSL_FORTEZZA_KEA_WITH_NULL_SHA         = { 0X00,0X1C };
  CipherSuite SSL_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA = { 0x00,0x1D };
  CipherSuite SSL_FORTEZZA_KEA_WITH_RC4_128_SHA      = { 0x00,0x1E };
]]>
	</artwork>
	</figure>
	</t>
	
<!--note--><t>Note:
             All cipher suites whose first byte is 0xFF are
                  considered private and can be used for defining
                  local/experimental algorithms.  Interoperability of
                  such types is a local matter.
	  </t>

</section>

<section anchor="the-cipherspec" title="The CipherSpec">
	<t>
	   A cipher suite identifies a CipherSpec.  These structures are part
	   of the SSL session state.  The CipherSpec includes:
	</t>
	<t>
	<figure><artwork><![CDATA[
     enum { stream, block } CipherType;

     enum { true, false } IsExportable;

     enum { null, rc4, rc2, des, 3des, des40, fortezza }
         BulkCipherAlgorithm;

     enum { null, md5, sha } MACAlgorithm;

     struct {
         BulkCipherAlgorithm bulk_cipher_algorithm;
         MACAlgorithm mac_algorithm;
         CipherType cipher_type;
         IsExportable is_exportable
         uint8 hash_size;
         uint8 key_material;
         uint8 IV_size;
     } CipherSpec;
]]>
	</artwork>
	</figure>
	</t>
</section>
</section>

<section anchor="glossary" title="Glossary">
	<t>
	<list style='hanging'>
		<t hangText="application protocol:">
			An application protocol is a protocol that
                          normally layers directly on top of the
                          transport layer (e.g., TCP/IP <xref target="RFC0793"/>/<xref target="RFC0791" />).  Examples
                          include HTTP <xref target="RFC1945"/>, TELNET <xref target="RFC0959"/>, FTP <xref target="RFC0854" />, and SMTP.</t>
		<t hangText="asymmetric cipher:">See public key cryptography.</t>
		<t hangText="authentication:">Authentication is the ability of one entity
				  to determine the identity of another entity.</t>
		<t hangText="block cipher:">A block cipher is an algorithm that operates
				  on plaintext in groups of bits, called
				  blocks.  64 bits is a typical block size.</t>
		<t hangText="bulk cipher:">A symmetric encryption algorithm used to
				  encrypt large quantities of data.</t>
		<t hangText="cipher block chaining (CBC) mode:">
				  CBC is a mode in which every
				  plaintext block encrypted with the block
				  cipher is first exclusive-ORed with the
				  previous ciphertext block (or, in the case
				  of the first block, with the initialization
				  vector).</t>
		<t hangText="certificate:">As part of the X.509 protocol (a.k.a. ISO
				  Authentication framework), certificates are
				  assigned by a trusted certificate authority
				  and provide verification of a party's
				  identity and may also supply its public key.</t>
		<t hangText="client:">The application entity that initiates a
				  connection to a server.</t>
		<t hangText="client write key:">The key used to encrypt data written by the
				  client.</t>
		<t hangText="client write MAC secret:">
				  The secret data used to authenticate data
				  written by the client.</t>
		<t hangText="connection:">A connection is a transport (in the OSI
				  layering model definition) that provides a
				  suitable type of service.  For SSL, such
				  connections are peer-to-peer relationships.
				  The connections are transient.  Every
				  connection is associated with one session.</t>
		<t hangText="Data Encryption Standard (DES):">
				  DES is a very widely used symmetric
				  encryption algorithm.  DES is a block
				  cipher <xref target="DES"/> <xref target="3DES" />.</t>
		<t hangText="Digital Signature Standard:">
				  (DSS) A standard for digital signing,
				  including the Digital Signature Algorithm,
				  approved by the National Institute of
				  Standards and Technology, defined in NIST
				  FIPS PUB 186, "Digital Signature Standard,"
				  published May, 1994 by the U.S. Dept.  of
				  Commerce.</t>
		<t hangText="digital signatures:">Digital signatures utilize public key
				  cryptography and one-way hash functions to
				  produce a signature of the data that can be
				  authenticated, and is difficult to forge or
				  repudiate.</t>
		<t hangText="FORTEZZA:">A PCMCIA card that provides both encryption
				  and digital signing.</t>
		<t hangText="handshake:">An initial negotiation between client and
				  server that establishes the parameters of
				  their transactions.</t>
		<t hangText="Initialization Vector (IV):">
				  When a block cipher is used in CBC
				  mode, the initialization vector is
				  exclusive-ORed with the first plaintext
				  block prior to encryption.</t>
		<t hangText="IDEA:">A 64-bit block cipher designed by Xuejia Lai
				  and James Massey <xref target="IDEA" />.</t>
		<t hangText="Message Authentication Code (MAC):">
				  A Message Authentication Code is a
				  one-way hash computed from a message and
				  some secret data.  Its purpose is to detect
				  if the message has been altered.</t>
		<t hangText="master secret:">Secure secret data used for generating
				  encryption keys, MAC secrets, and IVs.</t>
		<t hangText="MD5:">MD5 <xref target="RFC1321"/> is a secure hashing function that
				  converts an arbitrarily long data stream
				  into a digest of fixed size.</t>
		<t hangText="public key cryptography:">
				  A class of cryptographic techniques
				  employing two-key ciphers.  Messages
				  encrypted with the public key can only be
				  decrypted with the associated private key.
				  Conversely, messages signed with the private
				  key can be verified with the public key.</t>
		<t hangText="one-way hash function:">
				  A one-way transformation that converts an
				  arbitrary amount of data into a fixed-length
				  hash.  It is computationally hard to
				  reverse the transformation or to find
				  collisions.  MD5 and SHA are examples of
				  one-way hash functions.</t>
		<t hangText="RC2, RC4:">Proprietary bulk ciphers from RSA Data
				  Security, Inc.  (There is no good reference
				  to these as they are unpublished works;
				  however, see <xref target="RSADSI"/>).  RC2 is a block cipher
				  and RC4 is a stream cipher.</t>
		<t hangText="RSA:">A very widely used public key algorithm that
				  can be used for either encryption or digital
				  signing.</t>
		<t hangText="salt:">Non-secret random data used to make export
				  encryption keys resist precomputation
				  attacks.</t>
		<t hangText="server:">The server is the application entity that
				  responds to requests for connections from
				  clients.  The server is passive, waiting for
				  requests from clients.</t>
		<t hangText="session:">An SSL session is an association between a
				  client and a server.  Sessions are created
				  by the handshake protocol.  Sessions define
				  a set of cryptographic security parameters,
				  which can be shared among multiple
				  connections.  Sessions are used to avoid the
				  expensive negotiation of new security
				  parameters for each connection.</t>
		<t hangText="session identifier:">A session identifier is a value generated by
				  a server that identifies a particular
				  session.</t>
		<t hangText="server write key:">The key used to encrypt data written by the
				  server.</t>
		<t hangText="server write MAC secret:">
				  The secret data used to authenticate data
				  written by the server.</t>
		<t hangText="SHA:">   The Secure Hash Algorithm is defined in FIPS
				  PUB 180-1.  It produces a 20-byte output
				  <xref target="SHA"/>.</t>
		<t hangText="stream cipher:">An encryption algorithm that converts a key
				  into a cryptographically strong keystream,
				  which is then exclusive-ORed with the
				  plaintext.</t>
		<t hangText="symmetric cipher:">     See bulk cipher.</t>

	</list>
	</t>
</section>

<section anchor="ciphersuite-definitions" title="CipherSuite Definitions">
	<t>
	<figure><artwork>
	<![CDATA[
CipherSuite                  Is         Key            Cipher       Hash
                             Exportable Exchange

SSL_NULL_WITH_NULL_NULL               * NULL           NULL         NULL
SSL_RSA_WITH_NULL_MD5                 * RSA            NULL         MD5
SSL_RSA_WITH_NULL_SHA                 * RSA            NULL         SHA
SSL_RSA_EXPORT_WITH_RC4_40_MD5        * RSA_EXPORT     RC4_40       MD5
SSL_RSA_WITH_RC4_128_MD5                RSA            RC4_128      MD5
SSL_RSA_WITH_RC4_128_SHA                RSA            RC4_128      SHA
SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5    * RSA_EXPORT     RC2_CBC_40   MD5
SSL_RSA_WITH_IDEA_CBC_SHA               RSA            IDEA_CBC     SHA
SSL_RSA_EXPORT_WITH_DES40_CBC_SHA     * RSA_EXPORT     DES40_CBC    SHA
SSL_RSA_WITH_DES_CBC_SHA                RSA            DES_CBC      SHA
SSL_RSA_WITH_3DES_EDE_CBC_SHA           RSA            3DES_EDE_CBC SHA
SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA  * DH_DSS_EXPORT  DES40_CBC    SHA
SSL_DH_DSS_WITH_DES_CBC_SHA             DH_DSS         DES_CBC      SHA
SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA        DH_DSS         3DES_EDE_CBC SHA
SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA  * DH_RSA_EXPORT  DES40_CBC    SHA
SSL_DH_RSA_WITH_DES_CBC_SHA             DH_RSA         DES_CBC      SHA
SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA        DH_RSA         3DES_EDE_CBC SHA
SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA * DHE_DSS_EXPORT DES40_CBC    SHA
SSL_DHE_DSS_WITH_DES_CBC_SHA            DHE_DSS        DES_CBC      SHA
SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA       DHE_DSS        3DES_EDE_CBC SHA
SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA * DHE_RSA_EXPORT DES40_CBC    SHA
SSL_DHE_RSA_WITH_DES_CBC_SHA            DHE_RSA        DES_CBC      SHA
SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA       DHE_RSA        3DES_EDE_CBC SHA
SSL_DH_anon_EXPORT_WITH_RC4_40_MD5    * DH_anon_EXPORT RC4_40       MD5
SSL_DH_anon_WITH_RC4_128_MD5            DH_anon        RC4_128      MD5
SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA   DH_anon        DES40_CBC    SHA
SSL_DH_anon_WITH_DES_CBC_SHA            DH_anon        DES_CBC      SHA
SSL_DH_anon_WITH_3DES_EDE_CBC_SHA       DH_anon        3DES_EDE_CBC SHA
SSL_FORTEZZA_KEA_WITH_NULL_SHA          FORTEZZA_KEA   NULL         SHA
SSL_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA  FORTEZZA_KEA   FORTEZZA_CBC SHA
SSL_FORTEZZA_KEA_WITH_RC4_128_SHA       FORTEZZA_KEA   RC4_128      SHA
]]>
	</artwork>
	</figure>
	</t>
<!--
	<texttable anchor='suite_table'>
		<preamble></preamble>
		<ttcol width="55%" align='center'>CipherSuite</ttcol>
		<ttcol width="5%" align='center'>Is Exportable</ttcol>
		<ttcol width="15%" align='center'>Key Exchange</ttcol>
		<ttcol width="15%" align='center'>Cipher</ttcol>
		<ttcol width="10%" align='center'>Hash</ttcol>
<c>SSL_NULL_WITH_NULL_NULL</c><c>*</c><c> NULL</c><c>           NULL</c><c>         NULL</c>
<c>SSL_RSA_WITH_NULL_MD5</c><c>*</c><c> RSA</c><c>            NULL</c><c>         MD5</c>
<c>SSL_RSA_WITH_NULL_SHA</c><c>*</c><c> RSA</c><c>            NULL</c><c>         SHA</c>
<c>SSL_RSA_EXPORT_WITH_RC4_40_MD5</c><c>        *</c><c> RSA_EXPORT</c><c>     RC4_40</c><c>       MD5</c>
<c>SSL_RSA_WITH_RC4_128_MD5</c><c></c><c>RSA</c><c>            RC4_128</c><c>      MD5</c>
<c>SSL_RSA_WITH_RC4_128_SHA</c><c></c><c>RSA  </c><c>   RC4_128</c><c>      SHA</c>
<c>SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5</c><c>*</c><c> RSA_EXPORT</c><c>     RC2_CBC_40</c><c>   MD5</c>
<c>SSL_RSA_WITH_IDEA_CBC_SHA</c><c></c><c>RSA</c><c>            IDEA_CBC</c><c>     SHA</c>
<c>SSL_RSA_EXPORT_WITH_DES40_CBC_SHA</c><c>*</c><c> RSA_EXPORT</c><c>     DES40_CBC</c><c>    SHA</c>
<c>SSL_RSA_WITH_DES_CBC_SHA</c><c></c><c>RSA</c><c>            DES_CBC</c><c>      SHA</c>
<c>SSL_RSA_WITH_3DES_EDE_CBC_SHA</c><c></c><c>RSA</c><c>            3DES_EDE_CBC</c><c> SHA</c>
<c>SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA</c><c>*</c><c> DH_DSS_EXPORT</c><c>  DES40_CBC</c><c>    SHA</c>
<c>SSL_DH_DSS_WITH_DES_CBC_SHA</c><c></c><c>DH_DSS</c><c>         DES_CBC</c><c>      SHA</c>
<c>SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA</c><c></c><c>DH_DSS</c><c>         3DES_EDE_CBC</c><c> SHA</c>
<c>SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA</c><c>*</c><c>DH_RSA_EXPORT</c><c>  DES40_CBC</c><c>    SHA</c>
<c>SSL_DH_RSA_WITH_DES_CBC_SHA</c><c></c><c>DH_RSA</c><c>         DES_CBC</c><c>      SHA</c>
<c>SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA</c><c></c><c>DH_RSA</c><c>         3DES_EDE_CBC</c><c> SHA</c>
<c>SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA</c><c> *</c><c> DHE_DSS_EXPORT</c><c> DES40_CBC</c><c>    SHA</c>
<c>SSL_DHE_DSS_WITH_DES_CBC_SHA</c><c></c><c>            DHE_DSS</c><c>        DES_CBC</c><c>      SHA</c>
<c>SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA</c><c></c><c>       DHE_DSS</c><c>        3DES_EDE_CBC</c><c> SHA</c>
<c>SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA</c><c> *</c><c> DHE_RSA_EXPORT</c><c> DES40_CBC</c><c>    SHA</c>
<c>SSL_DHE_RSA_WITH_DES_CBC_SHA</c><c></c><c>            DHE_RSA</c><c>        DES_CBC</c><c>      SHA</c>
<c>SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA</c><c></c><c>       DHE_RSA</c><c>        3DES_EDE_CBC</c><c> SHA</c>
<c>SSL_DH_anon_EXPORT_WITH_RC4_40_MD5</c><c>*</c><c> DH_anon_EXPORT</c><c> RC4_40</c><c>       MD5</c>
<c>SSL_DH_anon_WITH_RC4_128_MD5</c><c></c><c>            DH_anon</c><c>        RC4_128</c><c>      MD5</c>
<c>SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA</c><c></c><c>   DH_anon</c><c>        DES40_CBC</c><c>    SHA</c>
<c>SSL_DH_anon_WITH_DES_CBC_SHA</c><c></c><c>            DH_anon</c><c>        DES_CBC</c><c>      SHA</c>
<c>SSL_DH_anon_WITH_3DES_EDE_CBC_SHA</c><c></c><c>       DH_anon</c><c>        3DES_EDE_CBC</c><c> SHA</c>
<c>SSL_FORTEZZA_KEA_WITH_NULL_SHA</c><c></c><c>          FORTEZZA_KEA</c><c>   NULL</c><c>         SHA</c>
<c>SSL_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA</c><c></c><c>FORTEZZA_KEA</c><c>   FORTEZZA_CBC</c><c> SHA</c>
<c>SSL_FORTEZZA_KEA_WITH_RC4_128_SHA</c><c></c><c>       FORTEZZA_KEA</c><c>   RC4_128</c><c>      SHA</c>
		<postamble></postamble>
	</texttable>	
-->
	<texttable anchor='kx_table'>
		<preamble></preamble>
		<ttcol width="20%" align='center'>Key Exchange Algorithm</ttcol>
		<ttcol width="50%" align='center'>Description</ttcol>
		<ttcol width="30%" align='center'>Key Size Limit</ttcol>
<c>   DHE_DSS</c><c>Ephemeral DH with DSS signatures</c><c>   None</c>
<c>   DHE_DSS_EXPORT</c><c>  Ephemeral DH with DSS signatures</c><c>   DH = 512 bits</c>
<c>   DHE_RSA</c><c>         Ephemeral DH with RSA signatures</c><c>None</c>
<c>   DHE_RSA_EXPORT</c><c>  Ephemeral DH with RSA signatures</c><c>DH = 512 bits, RSA = none</c>
<c>   DH_anon</c><c>         Anonymous DH, no signatures</c><c>        None</c>
<c>   DH_anon_EXPORT</c><c>  Anonymous DH, no signatures</c><c>        DH = 512 bits</c>
<c>   DH_DSS</c><c>          DH with DSS-based certificates</c><c>     None</c>
<c>   DH_DSS_EXPORT</c><c>   DH with DSS-based certificates</c><c>     DH = 512 bits</c>
<c>   DH_RSA</c><c>          DH with RSA-based certificates</c><c>     None</c>
<c>   DH_RSA_EXPORT</c><c>   DH with RSA-based certificates</c><c>     DH = 512 bits, RSA = none</c>
<c>   FORTEZZA_KEA</c><c>    FORTEZZA KEA. Details unpublished</c><c>  N/A</c>
<c>   NULL</c><c>            No key exchange</c><c>                    N/A</c>
<c>   RSA</c><c>             RSA key exchange</c><c>                   None</c>
<c>   RSA_EXPORT</c><c>      RSA key exchange</c><c>                   RSA = 512 bits</c>
		<postamble></postamble>
	</texttable>
	

	<t>
	<list style='hanging'>
		     <t hangText="Key size limit:">The key size limit gives the size of the
			       largest public key that can be legally
			       used for encryption in cipher suites that
			       are exportable.</t>
	</list>
	</t>

	<texttable anchor='cipher_table'>
		<preamble></preamble>
		<ttcol width="35%" align='left'>Cipher</ttcol>
		<ttcol width="14%" align='center'>Cipher Type</ttcol>
		<ttcol width="5%" align='center'>IsExportable</ttcol>
		<ttcol width="10%" align='center'>Key Material</ttcol>
		<ttcol width="10%" align='center'>Exp. Key Material</ttcol>
		<ttcol width="10%" align='center'>Effective Key Bits</ttcol>
		<ttcol width="8%" align='center'>IV Size</ttcol>
		<ttcol width="8%" align='center'>Block Size</ttcol>
<c>NULL</c><c>Stream</c><c>*</c><c>0</c><c>0</c><c>0</c><c>0</c><c>N/A</c>
<c>FORTEZZA_CBC</c><c>Block</c><c></c><c>NA (**)</c><c>12 (**)</c><c>96 (**)</c><c>20 (**)</c><c>8</c>
<c>IDEA_CBC</c><c>Block</c><c></c><c>16</c><c>16</c><c>128</c><c>8</c><c>8</c>
<c>RC2_CBC_40</c><c>Block</c><c>*</c><c>5</c><c>16</c><c>40</c><c>8</c><c>8</c>
<c>RC4_40</c><c>Stream</c><c>*</c><c>5</c><c>16</c><c>40</c><c>0</c><c>N/A</c>
<c>RC4_128</c><c>Stream</c><c></c><c>16</c><c>16</c><c>128</c><c>0</c><c>N/A</c>
<c>DES40_CBC</c><c>Block</c><c>*</c><c>5</c><c>8</c><c>40</c><c>8</c><c>8</c>
<c>DES_CBC</c><c>       Block</c><c></c><c>         8</c><c>       8</c><c>       56</c><c>      8</c><c>       8</c>
<c>3DES_EDE_CBC</c><c>  Block</c><c></c><c>         24</c><c>      24</c><c>      168</c><c>     8</c><c>       8</c>
		<postamble>
 * Indicates IsExportable is true.
<vspace />
** FORTEZZA uses its own key and IV generation algorithms.
		</postamble>
	</texttable>
	<t>
	<list style='hanging'>
		<t hangText="Key Material:">The number of bytes from the key_block that are
                       used for generating the write keys.</t>
		<t hangText="Expanded Key Material:">
                       The number of bytes actually fed into the
                       encryption algorithm.</t>
		<t hangText="Effective Key Bits:">
                       How much entropy material is in the key
                       material being fed into the encryption
                       routines.</t>
	</list>
	</t>
	<texttable anchor='hash_table'>
		<preamble></preamble>
		<ttcol align='center'>Hash Function</ttcol>
		<ttcol align='center'>Hash Size</ttcol>
		<ttcol align='center'>Padding Size</ttcol>
		<c>NULL</c><c>0</c><c>0</c>
		<c>MD5</c><c>16</c><c>48</c>
		<c>SHA</c><c>20</c><c>40</c>
		<postamble></postamble>
	</texttable>

</section>
<section anchor="implementation-notes" title="Implementation Notes">
	<t>
	   The SSL protocol cannot prevent many common security mistakes.
	   This section provides several recommendations to assist
	   implementers.
	</t>

<section anchor="temp-rsa-keys" title="Temporary RSA Keys">
	<t>
	   US export restrictions limit RSA keys used for encryption to 512
	   bits, but do not place any limit on lengths of RSA keys used for
	   signing operations.  Certificates often need to be larger than 512
	   bits, since 512-bit RSA keys are not secure enough for high-value
	   transactions or for applications requiring long-term security.
	   Some certificates are also designated signing-only, in which case
	   they cannot be used for key exchange.
	</t>
	<t>
		When the public key in the certificate cannot be used for
		encryption, the server signs a temporary RSA key, which is then
		exchanged.  In exportable applications, the temporary RSA key
		should be the maximum allowable length (i.e., 512 bits).  Because
		512-bit RSA keys are relatively insecure, they should be changed
		often.  For typical electronic commerce applications, it is
		suggested that keys be changed daily or every 500 transactions, and
		more often if possible.  Note that while it is acceptable to use
		the same temporary key for multiple transactions, it must be signed
		each time it is used.
	</t>
	<t>
	   RSA key generation is a time-consuming process.  In many cases, a
	   low-priority process can be assigned the task of key generation.
	   Whenever a new key is completed, the existing temporary key can be
	   replaced with the new one.
	</t>
</section>

<section anchor="random-number-generation" title="Random Number Generation and Seeding">
	<t>
	   SSL requires a cryptographically secure pseudorandom number
	   generator (PRNG).  Care must be taken in designing and seeding
	   PRNGs.  PRNGs based on secure hash operations, most notably MD5
	   and/or SHA, are acceptable, but cannot provide more security than
	   the size of the random number generator state.  (For example,
	   MD5-based PRNGs usually provide 128 bits of state.)
	</t>
	<t>
	   To estimate the amount of seed material being produced, add the
	   number of bits of unpredictable information in each seed byte.  For
	   example, keystroke timing values taken from a PC-compatible's 18.2
	   Hz timer provide 1 or 2 secure bits each, even though the total
	   size of the counter value is 16 bits or more.  To seed a 128-bit
	   PRNG, one would thus require approximately 100 such timer values.
	</t>

<!--note--><t>Note:
		The seeding functions in RSAREF and versions of
                  BSAFE prior to 3.0 are order independent.  For
                  example, if 1000 seed bits are supplied, one at a
                  time, in 1000 separate calls to the seed function,
                  the PRNG will end up in a state that depends only
                  on the number of 0 or 1 seed bits in the seed data
                  (i.e., there are 1001 possible final states).
                  Applications using BSAFE or RSAREF must take extra
                  care to ensure proper seeding.
	</t>
</section>

<section anchor="certificate-and-auth" title="Certificates and Authentication">
	<t>
	   Implementations are responsible for verifying the integrity of
	   certificates and should generally support certificate revocation
	   messages.  Certificates should always be verified to ensure proper
	   signing by a trusted certificate authority (CA).  The selection and
	   addition of trusted CAs should be done very carefully.  Users
	   should be able to view information about the certificate and root
	   CA.
	</t>
</section>
	
<section anchor="notes-ciphersuites" title="CipherSuites">
	<t>
	   SSL supports a range of key sizes and security levels, including
	   some that provide no or minimal security.  A proper implementation
	   will probably not support many cipher suites.  For example, 40-bit
	   encryption is easily broken, so implementations requiring strong
	   security should not allow 40-bit keys.  Similarly, anonymous
	   Diffie-Hellman is strongly discouraged because it cannot prevent
	   man-in-the- middle attacks.  Applications should also enforce
	   minimum and maximum key sizes.  For example, certificate chains
	   containing 512-bit RSA keys or signatures are not appropriate for
	   high-security applications.
	</t>
</section>

<section anchor="notes-fortezza" title="FORTEZZA">
	<t>
	   This section describes implementation details for cipher suites that
	   make use of the FORTEZZA hardware encryption system.
	</t>

<section anchor="notes-non-fortezza-hardware" title="Notes on Use of FORTEZZA Hardware">
	<t>
		A complete explanation of all issues regarding the use of FORTEZZA
		hardware is outside the scope of this document.  However, there are
		a few special requirements of SSL that deserve mention.
	</t>
	<t>
		Because SSL is a full duplex protocol, two crypto states must be
		maintained, one for reading and one for writing.  There are also a
		number of circumstances that can result in the crypto state in the
		FORTEZZA card being lost.  For these reasons, it's recommended that
		the current crypto state be saved after processing a record, and
		loaded before processing the next.
	</t>
	<t>
	   After the client generates the TEK, it also generates two message encryption keys (MEKs), one for reading and one for writing.  After generating each of
	   these keys, the client must generate a corresponding IV and then
	   save the crypto state.  The client also uses the TEK to generate an
	   IV and encrypt the premaster secret.  All three IVs are sent to the
	   server, along with the wrapped keys and the encrypted premaster
	   secret in the client key exchange message.  At this point, the TEK
	   is no longer needed, and may be discarded.
	</t>
	<t>
	   On the server side, the server uses the master IV and the TEK to
	   decrypt the premaster secret.  It also loads the wrapped MEKs into
	   the card.  The server loads both IVs to verify that the IVs match
	   the keys.  However, since the card is unable to encrypt after
	   loading an IV, the server must generate a new IV for the server
	   write key.  This IV is discarded.
	</t>
	<t>
	   When encrypting the first encrypted record (and only that record),
	   the server adds 8 bytes of random data to the beginning of the
	   fragment.  These 8 bytes are discarded by the client after
	   decryption.  The purpose of this is to synchronize the state on the
	   client and server resulting from the different IVs.
	</t>
</section>

<section anchor="notes-fortezza-ciphersuites" title="FORTEZZA Cipher Suites">
	<t>
	   5) FORTEZZA_NULL_WITH_NULL_SHA:
	     Uses the full FORTEZZA key exchange, including sending server and
	     client write keys and IVs.
	</t>
</section>

<section anchor="notes-fortezza-resumption" title="FORTEZZA Session Resumption">
	<t>
	   There are two possibilities for FORTEZZA session restart:
	   1) Never restart a FORTEZZA session.
	   2) Restart a session with the previously negotiated keys and IVs.
	</t>
	<t>
		Never restarting a FORTEZZA session:
	</t>
	<t>
	   Clients who never restart FORTEZZA sessions should never send
	   session IDs that were previously used in a FORTEZZA session as
	   part of the ClientHello.  Servers who never restart FORTEZZA
	   sessions should never send a previous session id on the
	   ServerHello if the negotiated session is FORTEZZA.
	</t>
	<t>Restart a session:</t>
	<t>
	   You cannot restart FORTEZZA on a session that has never done a
	   complete FORTEZZA key exchange (that is, you cannot restart FORTEZZA
	   if the session was an RSA/RC4 session renegotiated for FORTEZZA).
	   If you wish to restart a FORTEZZA session, you must save the MEKs
	   and IVs from the initial key exchange for this session and reuse
	   them for any new connections on that session.  This is not
	   recommended, but it is possible.
	</t>
</section>
</section>
</section>

<section anchor="ssl-2" title="Version 2.0 Backward Compatibility">
	<t>
	   Version 3.0 clients that support version 2.0 servers must send
	   version 2.0 client hello messages <xref target="SSL-2"/>.  Version 3.0 servers
	   should accept either client hello format.  The only deviations from
	   the version 2.0 specification are the ability to specify a version
	   with a value of three and the support for more ciphering types in
	   the CipherSpec.
	</t>
<!--note--><t>Warning:
		The ability to send version 2.0 client hello
                  messages will be phased out with all due haste.
                  Implementers should make every effort to move
                  forward as quickly as possible.  Version 3.0
                  provides better mechanisms for transitioning to
                  newer versions.
	</t>
	<t>
	   The following cipher specifications are carryovers from SSL version
	   2.0.  These are assumed to use RSA for key exchange and
	   authentication.
	</t>
	<t>
	<figure><artwork><![CDATA[
     V2CipherSpec SSL_RC4_128_WITH_MD5          = { 0x01,0x00,0x80 };
     V2CipherSpec SSL_RC4_128_EXPORT40_WITH_MD5 = { 0x02,0x00,0x80 };
     V2CipherSpec SSL_RC2_CBC_128_CBC_WITH_MD5  = { 0x03,0x00,0x80 };
     V2CipherSpec SSL_RC2_CBC_128_CBC_EXPORT40_WITH_MD5
                                                = { 0x04,0x00,0x80 };
     V2CipherSpec SSL_IDEA_128_CBC_WITH_MD5     = { 0x05,0x00,0x80 };
     V2CipherSpec SSL_DES_64_CBC_WITH_MD5       = { 0x06,0x00,0x40 };
     V2CipherSpec SSL_DES_192_EDE3_CBC_WITH_MD5 = { 0x07,0x00,0xC0 };
]]>
	</artwork>
	</figure>
	</t>
	<t>
	   Cipher specifications introduced in version 3.0 can be included in
	   version 2.0 client hello messages using the syntax below.  Any
	   V2CipherSpec element with its first byte equal to zero will be
	   ignored by version 2.0 servers.  Clients sending any of the above
	   V2CipherSpecs should also include the version 3.0 equivalent (see
	   <xref target="the-ciphersuite"/>):
	</t>
	<t>
	<figure><artwork><![CDATA[
     V2CipherSpec (see Version 3.0 name) = { 0x00, CipherSuite };
]]>
	</artwork>
	</figure>
	</t>

<section anchor="ssl-2-client-hello" title="Version 2 Client Hello">
	<t>
	   The version 2.0 client hello message is presented below using this
	   document's presentation model.  The true definition is still
	   assumed to be the SSL version 2.0 specification.
	</t>
	<t>
	<figure><artwork><![CDATA[
     uint8 V2CipherSpec[3];

     struct {
         unit8 msg_type;
         Version version;
         uint16 cipher_spec_length;
         uint16 session_id_length;
         uint16 challenge_length;
         V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];
         opaque session_id[V2ClientHello.session_id_length];
         Random challenge;
     } V2ClientHello;
]]>
	</artwork>
	</figure>
	</t>
	<t>
	<list style='hanging'>
	     <t hangText="session msg_type:">
               This field, in conjunction with the version
                       field, identifies a version 2 client hello
                       message.  The value should equal one (1).</t>
	     <t hangText="version:">The highest version of the protocol supported
			       by the client (equals ProtocolVersion.version;
			       see <xref target="record-layer-2"/>).</t>
	     <t hangText="cipher_spec_length:">
			       This field is the total length of the field
			       cipher_specs.  It cannot be zero and must be a
			       multiple of the V2CipherSpec length (3).</t>
	     <t hangText="session_id_length:">This field must have a value of either zero or
			       16.  If zero, the client is creating a new
			       session.  If 16, the session_id field will
			       contain the 16 bytes of session identification.</t>
	     <t hangText="challenge_length:">The length in bytes of the client's challenge
			       to the server to authenticate itself.  This
			       value must be 32.</t>
	     <t hangText="cipher_specs:">This is a list of all CipherSpecs the client is
			       willing and able to use.  There must be at
			       least one CipherSpec acceptable to the server.</t>
	     <t hangText="session_id:">If this field's length is not zero, it will
			       contain the identification for a session that
			       the client wishes to resume.</t>

	     <t hangText="challenge:">The client's challenge to the server for the
			       server to identify itself is a (nearly)
			       arbitrary length random.  The version 3.0
			       server will right justify the challenge data to
			       become the ClientHello.random data (padded with
			       leading zeroes, if necessary), as specified in
			       this version 3.0 protocol.  If the length of
			       the challenge is greater than 32 bytes, then
			       only the last 32 bytes are used.  It is
			       legitimate (but not necessary) for a V3 server
			       to reject a V2 ClientHello that has fewer than
			       16 bytes of challenge data.</t>
	</list>
	</t>
<!--note--><t>Note:
		Requests to resume an SSL 3.0 session should use an
                  SSL 3.0 client hello.
        </t>
</section>

<section anchor="ssl-2-mitm" title="Avoiding Man-in-the-Middle Version Rollback">
	<t>
	   When SSL version 3.0 clients fall back to version 2.0 compatibility
	   mode, they use special PKCS #1 block formatting.  This is done so
	   that version 3.0 servers will reject version 2.0 sessions with
	   version 3.0-capable clients.
	</t>
	<t>
	   When version 3.0 clients are in version 2.0 compatibility mode,
	   they set the right-hand (least-significant) 8 random bytes of the
	   PKCS padding (not including the terminal null of the padding) for
	   the RSA encryption of the ENCRYPTED-KEY-DATA field of the
	   CLIENT-MASTER-KEY to 0x03 (the other padding bytes are random).
	   After decrypting the ENCRYPTED-KEY-DATA field, servers that
	   support SSL 3.0 should issue an error if these eight padding bytes
	   are 0x03.  Version 2.0 servers receiving blocks padded in this
	   manner will proceed normally.
	</t>
</section>
</section>

<section anchor="security-analysis" title="Security Analysis">
	<t>
	   The SSL protocol is designed to establish a secure connection
	   between a client and a server communicating over an insecure
	   channel.  This document makes several traditional assumptions,
	   including that attackers have substantial computational resources
	   and cannot obtain secret information from sources outside the
	   protocol.  Attackers are assumed to have the ability to capture,
	   modify, delete, replay, and otherwise tamper with messages sent
	   over the communication channel.  This appendix outlines how SSL has
	   been designed to resist a variety of attacks.
	</t>
<section anchor="security-handshake" title="Handshake Protocol">
	<t>
	   The handshake protocol is responsible for selecting a CipherSpec
	   and generating a MasterSecret, which together comprise the primary
	   cryptographic parameters associated with a secure session.  The
	   handshake protocol can also optionally authenticate parties who
	   have certificates signed by a trusted certificate authority.
	</t>

<section anchor="security-authentication" title="Authentication and Key Exchange">
	<t>
	   SSL supports three authentication modes: authentication of both
	   parties, server authentication with an unauthenticated client, and
	   total anonymity.  Whenever the server is authenticated, the channel
	   should be secure against man-in-the-middle attacks, but completely
	   anonymous sessions are inherently vulnerable to such attacks.
	   Anonymous servers cannot authenticate clients, since the client
	   signature in the certificate verify message may require a server
	   certificate to bind the signature to a particular server.  If the
	   server is authenticated, its certificate message must provide a
	   valid certificate chain leading to an acceptable certificate
	   authority.  Similarly, authenticated clients must supply an
	   acceptable certificate to the server.  Each party is responsible
	   for verifying that the other's certificate is valid and has not
	   expired or been revoked.
	</t>
	<t>
	   The general goal of the key exchange process is to create a
	   pre_master_secret known to the communicating parties and not to
	   attackers.  The pre_master_secret will be used to generate the
	   master_secret (see <xref target="asymmetric-crypto-computations"/>).  The master_secret is required to
	   generate the finished messages, encryption keys, and MAC secrets
	   (see Sections <xref target="finished" format="counter"/> and <xref target="converting-master-secret" format="counter"/>).  By sending a correct finished
	   message, parties thus prove that they know the correct
	   pre_master_secret.
	</t>

<section anchor="security-anonymous-auth" title="Anonymous Key Exchange">
	<t>
	   Completely anonymous sessions can be established using RSA,
	   Diffie-Hellman, or FORTEZZA for key exchange.  With anonymous RSA,
	   the client encrypts a pre_master_secret with the server's
	   uncertified public key extracted from the server key exchange
	   message.  The result is sent in a client key exchange message.
	   Since eavesdroppers do not know the server's private key, it will
	   be infeasible for them to decode the pre_master_secret.
	</t>
	<t>
	   With Diffie-Hellman or FORTEZZA, the server's public parameters are
	   contained in the server key exchange message and the client's are
	   sent in the client key exchange message.  Eavesdroppers who do not
	   know the private values should not be able to find the
	   Diffie-Hellman result (i.e., the pre_master_secret) or the FORTEZZA
	   token encryption key (TEK).
	</t>
<!--note--><t>Warning:
		Completely anonymous connections only provide
                  protection against passive eavesdropping.  Unless an
                  independent tamper-proof channel is used to verify
                  that the finished messages were not replaced by an
                  attacker, server authentication is required in
                  environments where active man-in-the-middle attacks
                  are a concern.
	</t>
</section>

<section anchor="security-rsa-auth" title="RSA Key Exchange and Authentication">
	<t>
	   With RSA, key exchange and server authentication are combined.  The
	   public key either may be contained in the server's certificate or
	   may be a temporary RSA key sent in a server key exchange message.
	   When temporary RSA keys are used, they are signed by the server's
	   RSA or DSS certificate.  The signature includes the current
	   ClientHello.random, so old signatures and temporary keys cannot be
	   replayed.  Servers may use a single temporary RSA key for multiple
	   negotiation sessions.
	</t>
<!--note--><t>Note:
		The temporary RSA key option is useful if servers
                  need large certificates but must comply with
                  government-imposed size limits on keys used for key
                  exchange.
	</t>
	<t>
	   After verifying the server's certificate, the client encrypts a
	   pre_master_secret with the server's public key.  By successfully
	   decoding the pre_master_secret and producing a correct finished
	   message, the server demonstrates that it knows the private key
	   corresponding to the server certificate.
	</t>
	<t>
	   When RSA is used for key exchange, clients are authenticated using
	   the certificate verify message (see <xref target="certificate-verify"/>).  The client
	   signs a value derived from the master_secret and all preceding
	   handshake messages.  These handshake messages include the server
	   certificate, which binds the signature to the server, and
	   ServerHello.random, which binds the signature to the current
	   handshake process.
	</t>
</section>

<section anchor="security-diffie-hellman-auth" title="Diffie-Hellman Key Exchange with Authentication">
	<t>
	   When Diffie-Hellman key exchange is used, the server either can
	   supply a certificate containing fixed Diffie-Hellman parameters or
	   can use the server key exchange message to send a set of temporary
	   Diffie-Hellman parameters signed with a DSS or RSA certificate.
	   Temporary parameters are hashed with the hello.random values before
	   signing to ensure that attackers do not replay old parameters.  In
	   either case, the client can verify the certificate or signature to
	   ensure that the parameters belong to the server.
	</t><t>
	   If the client has a certificate containing fixed Diffie-Hellman
	   parameters, its certificate contains the information required to
	   complete the key exchange.  Note that in this case, the client and
	   server will generate the same Diffie-Hellman result (i.e.,
	   pre_master_secret) every time they communicate.  To prevent the
	   pre_master_secret from staying in memory any longer than necessary,
	   it should be converted into the master_secret as soon as possible.
	   Client Diffie-Hellman parameters must be compatible with those
	   supplied by the server for the key exchange to work.
	</t><t>
	   If the client has a standard DSS or RSA certificate or is
	   unauthenticated, it sends a set of temporary parameters to the
	   server in the client key exchange message, then optionally uses a
	   certificate verify message to authenticate itself.
	</t>
</section>

<section anchor="security-fortezza" title="FORTEZZA">
	<t>
	   FORTEZZA's design is classified, but at the protocol level it is
	   similar to Diffie-Hellman with fixed public values contained in
	   certificates.  The result of the key exchange process is the token
	   encryption key (TEK), which is used to wrap data encryption keys,
	   client write key, server write key, and master secret encryption
	   key.  The data encryption keys are not derived from the
	   pre_master_secret because unwrapped keys are not accessible outside
	   the token.  The encrypted pre_master_secret is sent to the server
	   in a client key exchange message.
	</t>
</section>
</section>
<section anchor="security-version-rollback" title="Version Rollback Attacks">
	<t>
	   Because SSL version 3.0 includes substantial improvements over SSL
	   version 2.0, attackers may try to make version 3.0-capable clients
	   and servers fall back to version 2.0.  This attack is occurring if
	   (and only if) two version 3.0-capable parties use an SSL 2.0
	   handshake.
	</t>
	<t>
	   Although the solution using non-random PKCS #1 block type 2 message
	   padding is inelegant, it provides a reasonably secure way for
	   version 3.0 servers to detect the attack.  This solution is not
	   secure against attackers who can brute force the key and substitute
	   a new ENCRYPTED-KEY-DATA message containing the same key (but with
	   normal padding) before the application specified wait threshold has
	   expired.  Parties concerned about attacks of this scale should not
	   be using 40-bit encryption keys anyway.  Altering the padding of
	   the least significant 8 bytes of the PKCS padding does not impact
	   security, since this is essentially equivalent to increasing the
	   input block size by 8 bytes.
	</t>
</section>

<section anchor="security-detecting-attacks" title="Detecting Attacks against the Handshake Protocol">
	<t>
	   An attacker might try to influence the handshake exchange to make
	   the parties select different encryption algorithms than they would
	   normally choose.  Because many implementations will support 40-bit
	   exportable encryption and some may even support null encryption or
	   MAC algorithms, this attack is of particular concern.
	</t>
	<t>
	   For this attack, an attacker must actively change one or more
	   handshake messages.  If this occurs, the client and server will
	   compute different values for the handshake message hashes.  As a
	   result, the parties will not accept each other's finished messages.
	   Without the master_secret, the attacker cannot repair the finished
	   messages, so the attack will be discovered.
	</t>
</section>

<section anchor="security-resuming-sessions" title="Resuming Sessions">
	<t>
	   When a connection is established by resuming a session, new
	   ClientHello.random and ServerHello.random values are hashed with
	   the session's master_secret.  Provided that the master_secret has
	   not been compromised and that the secure hash operations used to
	   produce the encryption keys and MAC secrets are secure, the
	   connection should be secure and effectively independent from
	   previous connections.  Attackers cannot use known encryption keys
	   or MAC secrets to compromise the master_secret without breaking the
	   secure hash operations (which use both SHA and MD5).
	</t><t>
	   Sessions cannot be resumed unless both the client and server agree.
	   If either party suspects that the session may have been
	   compromised, or that certificates may have expired or been revoked,
	   it should force a full handshake.  An upper limit of 24 hours is
	   suggested for session ID lifetimes, since an attacker who obtains a
	   master_secret may be able to impersonate the compromised party
	   until the corresponding session ID is retired.  Applications that
	   may be run in relatively insecure environments should not write
	   session IDs to stable storage.
	</t>
</section>
<section anchor="security-md5-and-sha" title="MD5 and SHA">
	<t>
	   SSL uses hash functions very conservatively.  Where possible, both
	   MD5 and SHA are used in tandem to ensure that non-catastrophic
	   flaws in one algorithm will not break the overall protocol.
	</t>
</section>
</section>

<section anchor="protecting-app-data" title="Protecting Application Data">
	<t>
	   The master_secret is hashed with the ClientHello.random and
	   ServerHello.random to produce unique data encryption keys and MAC
	   secrets for each connection.  FORTEZZA encryption keys are
	   generated by the token, and are not derived from the master_secret.
	</t>
	<t>
	   Outgoing data is protected with a MAC before transmission.  To
	   prevent message replay or modification attacks, the MAC is computed
	   from the MAC secret, the sequence number, the message length, the
	   message contents, and two fixed-character strings.  The message
	   type field is necessary to ensure that messages intended for one
	   SSL record layer client are not redirected to another.  The
	   sequence number ensures that attempts to delete or reorder messages
	   will be detected.  Since sequence numbers are 64 bits long, they
	   should never overflow.  Messages from one party cannot be inserted
	   into the other's output, since they use independent MAC secrets.
	   Similarly, the server-write and client-write keys are independent
	   so stream cipher keys are used only once.
	</t><t>
	   If an attacker does break an encryption key, all messages encrypted
	   with it can be read.  Similarly, compromise of a MAC key can make
	   message modification attacks possible.  Because MACs are also
	   encrypted, message-alteration attacks generally require breaking
	   the encryption algorithm as well as the MAC.
	</t>
<!--note--><t>Note:
		MAC secrets may be larger than encryption keys, so
                  messages can remain tamper resistant even if
                  encryption keys are broken.
        </t>
</section>

<section anchor="final-notes" title="Final Notes">
	<t>
		For SSL to be able to provide a secure connection, both the client
		and server systems, keys, and applications must be secure.  In
		addition, the implementation must be free of security errors.
	</t>
	<t>
	   The system is only as strong as the weakest key exchange and
	   authentication algorithm supported, and only trustworthy
	   cryptographic functions should be used.  Short public keys, 40-bit
	   bulk encryption keys, and anonymous servers should be used with
	   great caution.  Implementations and users must be careful when
	   deciding which certificates and certificate authorities are
	   acceptable; a dishonest certificate authority can do tremendous
	   damage.
	</t>
</section>
</section>


<section title="Acknowledgements">
<section title="Other Contributors">
<t>
<figure>
<artwork><![CDATA[
           Martin Abadi                  Robert Relyea
           Digital Equipment Corporation Netscape Communications
           ma@pa.dec.com                 relyea@netscape.com

           Taher Elgamal                 Jim Roskind
           Netscape Communications       Netscape Communications
           elgamal@netscape.com          jar@netscape.com

           Anil Gangolli                 Micheal J. Sabin, Ph.D.
           Netscape Communications       Consulting Engineer
           gangolli@netscape.com         msabin@netcom.com

           Kipp E.B. Hickman             Tom Weinstein
           Netscape Communications       Netscape Communications
           kipp@netscape.com             tomw@netscape.com
]]>
	</artwork>
	</figure>
	</t>
</section>
<section title="Early Reviewers">
<t>
<figure>
<artwork><![CDATA[
   Robert Baldwin                Clyde Monma
   RSA Data Security, Inc.       Bellcore
   baldwin@rsa.com               clyde@bellcore.com

   George Cox                    Eric Murray
   Intel Corporation             ericm@lne.com
   cox@ibeam.jf.intel.com

   Cheri Dowell                  Avi Rubin
   Sun Microsystems              Bellcore
   cheri@eng.sun.com             rubin@bellcore.com

   Stuart Haber                  Don Stephenson
   Bellcore                      Sun Microsystems
   stuart@bellcore.com           don.stephenson@eng.sun.com

   Burt Kaliski                  Joe Tardo
   RSA Data Security, Inc.       General Magic
   burt@rsa.com                  tardo@genmagic.com
]]>
	</artwork>
	</figure>
	</t>
</section>

</section>

</back>
</rfc>
